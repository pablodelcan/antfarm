<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Antfarm</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;1,400&family=Inter:wght@300;400;500&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #fff; color: #1a1a1a;
    font-family: 'Inter', -apple-system, sans-serif;
    height: 100vh; overflow: hidden; -webkit-font-smoothing: antialiased;
  }
  .intro {
    position: fixed; inset: 0; background: #fff;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 100; transition: opacity 0.8s ease;
  }
  .intro.hide { opacity: 0; pointer-events: none; }
  .intro h1 { font-family: 'EB Garamond', serif; font-size: clamp(2.5rem, 5vw, 4.5rem); font-weight: 400; margin-bottom: 12px; }
  .intro h1 em { font-style: italic; }
  .intro .sub { color: #999; font-size: 0.82rem; letter-spacing: 0.08em; margin-bottom: 48px; }
  .intro button {
    background: none; border: 1px solid #ddd; color: #1a1a1a;
    font-family: 'Inter', sans-serif; font-size: 0.78rem; letter-spacing: 0.14em;
    text-transform: uppercase; padding: 14px 44px; cursor: pointer; transition: all 0.3s;
  }
  .intro button:hover { border-color: #1a1a1a; background: #1a1a1a; color: #fff; }
  .app { display: none; height: 100vh; flex-direction: column; }
  .app.show { display: flex; }
  .topbar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 24px; height: 48px; flex-shrink: 0; border-bottom: 1px solid #eee;
  }
  .topbar .title { font-family: 'EB Garamond', serif; font-size: 1.15rem; font-weight: 400; }
  .topbar .title em { font-style: italic; }
  .topbar .stats { display: flex; gap: 24px; font-size: 0.72rem; color: #999; letter-spacing: 0.04em; }
  .topbar .stats .v { color: #1a1a1a; font-weight: 500; margin-left: 6px; font-variant-numeric: tabular-nums; }
  .canvas-wrap {
    flex: 1; position: relative; overflow: hidden;
    background: #e8e0d4; cursor: crosshair;
    display: flex; align-items: center; justify-content: center;
  }
  .canvas-wrap canvas { display: block; }
  .ant-tooltip {
    position: fixed; pointer-events: none;
    background: rgba(255,255,255,0.95); backdrop-filter: blur(8px);
    border: 1px solid #e0e0e0; padding: 8px 12px;
    font-size: 0.68rem; line-height: 1.5; color: #555;
    z-index: 50; opacity: 0; transition: opacity 0.15s ease; max-width: 220px; white-space: nowrap;
  }
  .ant-tooltip.show { opacity: 1; }
  .ant-tooltip .tt-name { color: #1a1a1a; font-weight: 500; margin-bottom: 2px; font-size: 0.72rem; }
  .ant-tooltip .tt-row { display: flex; justify-content: space-between; gap: 12px; }
  .ant-tooltip .tt-val { color: #1a1a1a; font-weight: 500; }
  .bottombar {
    display: flex; align-items: center; justify-content: center; gap: 1px;
    height: 40px; flex-shrink: 0; border-top: 1px solid #eee; background: #fff;
  }
  .bottombar button {
    background: #fff; border: none; border-right: 1px solid #eee; color: #888;
    font-family: 'Inter', sans-serif; font-size: 0.7rem; letter-spacing: 0.06em;
    padding: 0 20px; height: 100%; cursor: pointer; transition: all 0.15s;
    display: flex; align-items: center; gap: 6px;
  }
  .bottombar button:last-child { border-right: none; }
  .bottombar button:hover { background: #f8f8f8; color: #1a1a1a; }
  .bottombar .speed-label { font-variant-numeric: tabular-nums; min-width: 22px; text-align: center; color: #1a1a1a; font-weight: 500; }
  .toast {
    position: fixed; bottom: 56px; left: 50%; transform: translateX(-50%) translateY(8px);
    background: #1a1a1a; color: #fff; padding: 8px 20px; font-size: 0.72rem;
    opacity: 0; transition: all 0.25s ease; z-index: 90; pointer-events: none;
  }
  .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
  .ai-thought {
    position: fixed; bottom: 56px; right: 24px;
    background: rgba(255,255,255,0.95); backdrop-filter: blur(8px);
    border: 1px solid #e0e0e0; padding: 8px 14px;
    font-size: 0.68rem; line-height: 1.4; color: #555;
    z-index: 90; opacity: 0; transition: all 0.4s ease; max-width: 260px;
    pointer-events: none;
  }
  .ai-thought.show { opacity: 1; }
  .ai-thought .ai-name { color: #1a1a1a; font-weight: 500; font-size: 0.7rem; }
  .ai-thought .ai-text { color: #666; margin-top: 2px; font-style: italic; }
</style>
</head>
<body>

<div class="intro" id="intro">
  <h1><em>Antfarm</em></h1>
  <p class="sub">a living colony simulation</p>
  <button onclick="begin()">Enter</button>
</div>

<div class="app" id="app">
  <div class="topbar">
    <div class="title"><em>Antfarm</em></div>
    <div class="stats">
      <span>Population<span class="v" id="sAnts">0</span></span>
      <span>Tunneled<span class="v" id="sTunnel">0%</span></span>
      <span>Chambers<span class="v" id="sChambers">0</span></span>
      <span>Day<span class="v" id="sDay">1</span></span>
    </div>
  </div>
  <div class="canvas-wrap" id="wrap">
    <canvas id="c"></canvas>
  </div>
  <div class="bottombar">
    <button onclick="dropAnts(5)"><span>+</span> 5 ants</button>
    <button onclick="dropAnts(1)"><span>+</span> 1 ant</button>
    <button onclick="dropFood()">food</button>
    <button onclick="cycleSpeed()"><span class="speed-label" id="speedLabel">1x</span></button>
    <button onclick="togglePause()" id="pauseBtn">pause</button>
  </div>
</div>

<div class="ant-tooltip" id="tooltip">
  <div class="tt-name" id="ttName"></div>
  <div class="tt-row"><span>State</span><span class="tt-val" id="ttState"></span></div>
  <div class="tt-row"><span>Energy</span><span class="tt-val" id="ttEnergy"></span></div>
  <div class="tt-row"><span>Age</span><span class="tt-val" id="ttAge"></span></div>
  <div class="tt-row"><span>Role</span><span class="tt-val" id="ttRole"></span></div>
  <div class="tt-row"><span>Thought</span><span class="tt-val" id="ttThought"></span></div>
</div>
<div class="toast" id="toast"></div>
<div class="ai-thought" id="aiThought">
  <div class="ai-name" id="aiName"></div>
  <div class="ai-text" id="aiText"></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════
//  ANTFARM v4 — Research-driven realistic colony simulation
//
//  Based on published myrmecology research:
//  - Speed: harvester ants 1.5-3 cm/s (~3-6 BL/s), 30-50% slower loaded
//  - Gait: alternating tripod, sinusoidal body oscillation
//  - Correlated random walk with ±15-20° per step, meandering ~3 BL wavelength
//  - Movement pauses (strobing): ~43% paused time at 5-7 Hz bursts
//  - Pheromone trails with exponential decay
//  - Stigmergy: extend existing tunnels, follow walls
//  - 20% of colony resting at any moment
//  - Self-organized role allocation via response thresholds
//  - Sand displacement: ants carry excavated grains to surface, build mounds
//  - Tandem running: experienced ants guide naive ones at 25% speed
//  - AI awareness: periodic situational assessment every ~60s
//  - Antennation: antenna-touching for communication within 1 body length
//  - Digging: ~10 grains/min, prefer loose grains, angle of repose ~40°
//  - Tunnel geometry: piecewise linear segments, 1-2 body widths
// ═══════════════════════════════════════════════════════════════════

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

// ── Dimensions ──
// Farm is ~40cm wide = 960px, so 1cm = 24px
// Harvester ant body ~6mm = ~14.4px, use ~14px
const W = 960, H = 680;
const CELL = 3; // 3px cells — smoother terrain, less pixelation
const COLS = W / CELL, ROWS = Math.ceil(H / CELL);
const SURFACE = Math.round(ROWS * 0.27);
const SURFACE_PX = SURFACE * CELL;
const FRAME = 14;

// ── Real-world scale ──
// 1 pixel = 0.417mm (960px = 40cm)
// Ant body = 6mm = ~14.4px
// Speed: 2cm/s = 48px/s = 0.8px/frame at 60fps
const PX_PER_CM = 24;
const ANT_BODY_PX = 14;

// ── Simulation State ──
let grid, phTrail, phFood, phDig;
let ants = [], foods = [], particles = [], chambers = [];
let frame = 0, totalDug = 0, simDay = 1;
let speed = 1, paused = false, running = false;
let hoveredAnt = null, mouseX = 0, mouseY = 0;
let hasQueen = false;

// ── Smooth terrain ──
// Multi-octave Perlin-like noise for natural sand texture
let sandNoise;
let terrainDirty = true; // flag to re-render terrain only when changed

// ── Offscreen terrain canvas ──
const tOff = document.createElement('canvas');
tOff.width = W; tOff.height = H;
const tCtx = tOff.getContext('2d');

// ═══════════════════════════════════════════════════════════════════
//  TERRAIN — Smooth, non-pixelated sand rendering
// ═══════════════════════════════════════════════════════════════════

// Improved noise: value noise with smooth interpolation
function smoothNoise(x, y, seed) {
  const ix = Math.floor(x), iy = Math.floor(y);
  const fx = x - ix, fy = y - iy;
  // Smoothstep
  const sx = fx * fx * (3 - 2 * fx);
  const sy = fy * fy * (3 - 2 * fy);
  const n00 = hashN(ix, iy, seed);
  const n10 = hashN(ix + 1, iy, seed);
  const n01 = hashN(ix, iy + 1, seed);
  const n11 = hashN(ix + 1, iy + 1, seed);
  return lerp(lerp(n00, n10, sx), lerp(n01, n11, sx), sy);
}
function hashN(x, y, s) { let n = Math.sin(x * 127.1 + y * 311.7 + s * 73.3) * 43758.5453; return n - Math.floor(n); }
function lerp(a, b, t) { return a + (b - a) * t; }

function fbm(x, y) {
  return smoothNoise(x, y, 0) * 0.5
       + smoothNoise(x * 2.1, y * 2.3, 1) * 0.25
       + smoothNoise(x * 4.7, y * 4.1, 2) * 0.125
       + smoothNoise(x * 9.3, y * 8.7, 3) * 0.0625;
}

function genSandNoise() {
  // Pre-compute multi-frequency noise for every pixel
  sandNoise = new Float32Array(W * H);
  for (let py = 0; py < H; py++) {
    for (let px = 0; px < W; px++) {
      // Combine multiple scales for natural texture
      const n1 = smoothNoise(px * 0.02, py * 0.02, 10) * 0.5;
      const n2 = smoothNoise(px * 0.05, py * 0.05, 20) * 0.25;
      const n3 = smoothNoise(px * 0.12, py * 0.12, 30) * 0.125;
      const n4 = smoothNoise(px * 0.3, py * 0.3, 40) * 0.0625;
      sandNoise[py * W + px] = (n1 + n2 + n3 + n4 - 0.45) * 2;
    }
  }
}

function initTerrain() {
  grid = new Uint8Array(COLS * ROWS);
  phTrail = new Float32Array(COLS * ROWS);
  phFood = new Float32Array(COLS * ROWS);
  phDig = new Float32Array(COLS * ROWS);

  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (y < SURFACE) { grid[y * COLS + x] = 0; continue; }
      const d = (y - SURFACE) / (ROWS - SURFACE);
      const n = fbm(x * 0.04, y * 0.04) - 0.4;
      // Softer terrain — mostly 1-3, only deepest areas reach 4
      grid[y * COLS + x] = Math.max(1, Math.min(4, Math.round(1 + d * 2.5 + n * 1.0)));
    }
  }
  // Rocks — just a few small ones
  for (let k = 0; k < 4; k++) {
    const cx = (Math.random() * (COLS - 14) + 7) | 0;
    const cy = (Math.random() * (ROWS - SURFACE - 20) + SURFACE + 14) | 0;
    const r = 2 + (Math.random() * 3) | 0;
    for (let dy = -r; dy <= r; dy++) for (let dx = -r; dx <= r; dx++) {
      if (dx * dx + dy * dy <= r * r) {
        const nx = cx + dx, ny = cy + dy;
        if (nx >= 0 && nx < COLS && ny >= SURFACE && ny < ROWS) grid[ny * COLS + nx] = 5;
      }
    }
  }
  terrainDirty = true;
}

function cellAt(x, y) { return (x < 0 || x >= COLS || y < 0 || y >= ROWS) ? 255 : grid[y * COLS + x]; }
function isSolid(x, y) { return cellAt(x, y) > 0; }

// Sand displacement: dig always returns 1 when material is removed
// Every dig action produces a grain the ant must carry out
function digCell(x, y) {
  if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return 0;
  const i = y * COLS + x;
  if (!grid[i]) return 0;
  if (grid[i] <= 1) { grid[i] = 0; totalDug++; terrainDirty = true; return 1; }
  grid[i]--; terrainDirty = true; return 1; // always return 1 — every chip produces a grain
}

// Deposit sand on surface — builds mounds around tunnel entrances
function depositSandOnSurface(gx) {
  // Find the highest open cell near the surface
  let depositY = SURFACE;
  for (let y = Math.max(0, SURFACE - 10); y < Math.min(ROWS, SURFACE + 5); y++) {
    if (isSolid(gx, y)) { depositY = y - 1; break; }
  }
  if (depositY < 2) return;
  // 82% stays put, 18% rolls sideways (research-backed)
  let nx = gx;
  if (Math.random() > 0.82) {
    nx += Math.random() < 0.5 ? -1 : 1;
    nx = Math.max(1, Math.min(COLS - 2, nx));
  }
  if (depositY >= 0 && depositY < ROWS && !isSolid(nx, depositY)) {
    grid[depositY * COLS + nx] = 1;
    terrainDirty = true;
  }
}

// Smooth SDF-like air fraction for edge blending
function airFraction(gx, gy) {
  let air = 0, total = 0;
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      total++;
      if (!isSolid(gx + dx, gy + dy)) air++;
    }
  }
  return air / total;
}

function gravity() {
  for (let y = ROWS - 2; y >= SURFACE; y--) {
    for (let x = 0; x < COLS; x++) {
      const v = grid[y * COLS + x];
      if (!v || v > 2) continue;
      if (!cellAt(x, y + 1)) {
        grid[(y + 1) * COLS + x] = v; grid[y * COLS + x] = 0; terrainDirty = true;
      } else {
        const cl = !cellAt(x - 1, y + 1) && !cellAt(x - 1, y);
        const cr = !cellAt(x + 1, y + 1) && !cellAt(x + 1, y);
        if (cl && cr) {
          const d = Math.random() < 0.5 ? -1 : 1;
          grid[(y + 1) * COLS + (x + d)] = v; grid[y * COLS + x] = 0; terrainDirty = true;
        } else if (cl) {
          grid[(y + 1) * COLS + (x - 1)] = v; grid[y * COLS + x] = 0; terrainDirty = true;
        } else if (cr) {
          grid[(y + 1) * COLS + (x + 1)] = v; grid[y * COLS + x] = 0; terrainDirty = true;
        }
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════════════
//  PHEROMONES
// ═══════════════════════════════════════════════════════════════════

function phSet(x, y, v, m) { if (x >= 0 && x < COLS && y >= 0 && y < ROWS) m[y * COLS + x] = Math.min(1.5, m[y * COLS + x] + v); }
function phGet(x, y, m) { return (x >= 0 && x < COLS && y >= 0 && y < ROWS) ? m[y * COLS + x] : 0; }

function phDecay() {
  for (let i = 0; i < phTrail.length; i++) {
    phTrail[i] *= 0.993; phFood[i] *= 0.996; phDig[i] *= 0.99;
    if (phTrail[i] < 0.003) phTrail[i] = 0;
    if (phFood[i] < 0.003) phFood[i] = 0;
    if (phDig[i] < 0.003) phDig[i] = 0;
  }
}

function phGradient(gx, gy, map, radius) {
  let bestVal = phGet(gx, gy, map);
  let bestAngle = null;
  const r = radius || 5;
  for (let a = 0; a < 6.28; a += 0.524) {
    const cx = gx + Math.round(Math.cos(a) * r);
    const cy = gy + Math.round(Math.sin(a) * r);
    const v = phGet(cx, cy, map);
    if (v > bestVal + 0.01) { bestVal = v; bestAngle = a; }
  }
  return { angle: bestAngle, strength: bestVal };
}

// ═══════════════════════════════════════════════════════════════════
//  CHAMBERS
// ═══════════════════════════════════════════════════════════════════

function detectChambers() {
  chambers = [];
  const vis = new Uint8Array(COLS * ROWS);
  for (let y = SURFACE + 5; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const i = y * COLS + x;
      if (!grid[i] && !vis[i]) {
        let n = 0, sx = 0, sy = 0;
        const q = [[x, y]]; vis[i] = 1;
        while (q.length && n < 1200) {
          const [cx, cy] = q.pop(); n++; sx += cx; sy += cy;
          for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
            const nx = cx + dx, ny = cy + dy;
            if (nx >= 0 && nx < COLS && ny >= SURFACE && ny < ROWS) {
              const ni = ny * COLS + nx;
              if (!grid[ni] && !vis[ni]) { vis[ni] = 1; q.push([nx, ny]); }
            }
          }
        }
        if (n >= 40) chambers.push({ x: (sx / n) * CELL, y: (sy / n) * CELL, size: n });
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════════════
//  AI AWARENESS SYSTEM
//  Every ~60 seconds, ants gain situational awareness — they assess
//  their environment and make intelligent decisions
// ═══════════════════════════════════════════════════════════════════

const AI_INTERVAL = 3600; // 60s at 60fps
let lastAITick = 0;

function aiAwarenessPass() {
  // Colony-level assessment
  const diggerCount = ants.filter(a => a.role === 'digger').length;
  const foragerCount = ants.filter(a => a.role === 'forager').length;
  const explorerCount = ants.filter(a => a.role === 'explorer').length;
  const idleCount = ants.filter(a => a.role === 'idle').length;
  const totalAnts = ants.length;
  const foodAvail = foods.reduce((s, f) => s + f.amount, 0);
  const tunnelPct = totalDug / ((ROWS - SURFACE) * COLS);

  // Each ant gets a moment of awareness
  for (const ant of ants) {
    if (ant.isQueen || ant.state === ST.REST) continue;

    // Calculate personal situation assessment
    const gx = ant.gx(), gy = ant.gy();
    const depth = ant.depthR();
    const atSurface = ant.atSurface();
    const nearbyAnts = ants.filter(a => a !== ant && Math.hypot(a.x - ant.x, a.y - ant.y) < 40).length;
    const nearbyDiggers = ants.filter(a => a !== ant && a.role === 'digger' && Math.hypot(a.x - ant.x, a.y - ant.y) < 40).length;

    // Situational reasoning
    let thought = '';
    let action = null;

    // Too many diggers at my location? Switch to exploring
    if (ant.role === 'digger' && nearbyDiggers > 3) {
      action = 'explore';
      thought = 'Too crowded here, I should explore elsewhere';
    }
    // Colony needs more diggers?
    else if (diggerCount < totalAnts * 0.3 && tunnelPct < 0.15 && ant.role === 'idle') {
      action = 'dig';
      thought = 'Colony needs more tunnels, I should dig';
    }
    // Food is scarce and I'm idle?
    else if (foodAvail > 0 && foragerCount < 2 && ant.role !== 'forager') {
      action = 'forage';
      thought = 'Food spotted but few foragers, I should help';
    }
    // Deep underground and tired?
    else if (depth > 0.6 && ant.energy < 300) {
      action = 'return';
      thought = 'Getting tired this deep, heading back up';
    }
    // Stuck in a dead end?
    else if (ant.stuck > 15) {
      action = 'unstick';
      thought = 'Stuck in a dead end, need to find another way';
    }
    // Nothing happening nearby and I've been idle?
    else if (ant.role === 'idle' && ant.patience > 150) {
      if (tunnelPct < 0.3) {
        action = 'dig';
        thought = 'Been idle too long, time to contribute';
      } else {
        action = 'explore';
        thought = 'Curious about what is down there';
      }
    }
    // Can I teach a nearby naive ant?
    else if (ant.experience > 500 && !ant.tandemTarget) {
      const naive = ants.find(a => a !== ant && a.experience < 100 && Math.hypot(a.x - ant.x, a.y - ant.y) < 30 && !a.tandemLeader);
      if (naive) {
        ant.tandemTarget = naive;
        naive.tandemLeader = ant;
        thought = 'Leading ' + naive.name.split('-')[0] + ' to the dig site';
        action = 'tandem';
      }
    }

    // Apply the decision
    if (action === 'dig') {
      ant.role = 'digger';
      ant.state = atSurface ? ST.ENTER : ST.DIG_BRANCH;
      ant.digAngle = Math.PI * 0.5 + (Math.random() - 0.5) * 0.3;
    } else if (action === 'explore') {
      ant.role = 'explorer';
      ant.state = ST.EXPLORE;
    } else if (action === 'forage') {
      ant.role = 'forager';
      ant.state = ST.FORAGE;
    } else if (action === 'return') {
      ant.state = ST.GO_UP;
    } else if (action === 'unstick') {
      ant._unstick(gx, gy);
    }

    ant.lastThought = thought || ant.lastThought;
    ant.lastThoughtTime = thought ? frame : ant.lastThoughtTime;
  }

  // Show a random ant's thought bubble
  const thinkingAnts = ants.filter(a => a.lastThought && frame - a.lastThoughtTime < 60);
  if (thinkingAnts.length > 0) {
    const ant = thinkingAnts[(Math.random() * thinkingAnts.length) | 0];
    showAIThought(ant.name, ant.lastThought);
  }
}

function showAIThought(name, text) {
  const el = document.getElementById('aiThought');
  document.getElementById('aiName').textContent = name;
  document.getElementById('aiText').textContent = text;
  el.classList.add('show');
  clearTimeout(el._t);
  el._t = setTimeout(() => el.classList.remove('show'), 5000);
}

// ═══════════════════════════════════════════════════════════════════
//  ANT AGENT — Research-based emergent behavior with sand carrying
// ═══════════════════════════════════════════════════════════════════

const ST = {
  WANDER: 0, ENTER: 1, DIG_DOWN: 2, DIG_BRANCH: 3, DIG_CHAMBER: 4,
  EXPLORE: 5, GO_UP: 6, FORAGE: 7, CARRY: 8, REST: 9, WALL_FOLLOW: 10,
  HAUL_SAND: 11, TANDEM_LEAD: 12, TANDEM_FOLLOW: 13, ANTENNATE: 14, PAUSE: 15
};
const ST_NAMES = [
  'Wandering', 'Entering', 'Digging down', 'Branching', 'Carving chamber',
  'Exploring', 'Returning', 'Foraging', 'Carrying food', 'Resting', 'Wall following',
  'Hauling sand', 'Leading', 'Following', 'Communicating', 'Pausing'
];

let nextId = 1;

// Research-backed speed:
// Harvester ant: 2cm/s unloaded = 48px/s = 0.8px/frame
// Loaded: 30-50% slower = 0.4-0.56px/frame
// Tunnel speed: same as surface
const BASE_SPEED = 0.8;  // 2cm/s in px/frame at 60fps
const LOADED_SPEED = 0.45; // ~44% reduction when carrying (research: 30-50%)
const TANDEM_SPEED = 0.2; // 25% of normal (research-backed)

class Ant {
  constructor(x, y, isQueen) {
    this.id = nextId++;
    this.x = x; this.y = y; this.px = x; this.py = y;
    this.vx = 0; this.vy = 0;
    this.state = ST.WANDER;
    this.energy = 900 + Math.random() * 200;
    this.carrying = false;
    this.carryingSand = 0; // grains of sand being hauled to surface
    this.maxSandCarry = 3 + Math.floor(Math.random() * 3); // carry 3-5 grains then haul
    this.isQueen = isQueen || false;
    this.age = 0; this.stuck = 0; this.digCD = 0;
    this.patience = 0;
    this.digCount = 0;
    this.experience = 0; // accumulated knowledge for tandem running

    // Correlated random walk
    this.heading = Math.random() * 6.28;
    this.digAngle = Math.PI * 0.5;
    this.targetX = -1; this.targetY = -1;

    // Meandering: real ants meander left-right with ~3 body-length wavelength
    this.meanderPhase = Math.random() * 6.28;
    this.meanderFreq = 0.08 + Math.random() * 0.04; // ~3 BL wavelength

    // Strobing/pause behavior: ants pause ~43% of time at 5-7Hz bursts
    this.pauseTimer = 0;
    this.pauseDuration = 0;
    this.nextPauseAt = 8 + Math.random() * 12; // frames between pauses
    this.isPaused = false;

    // Rest cycle: ~250 naps/day
    this.restTimer = 0;
    this.nextRestAt = 180 + Math.random() * 220;
    this.restDuration = 35 + Math.random() * 45;
    this.timeSinceRest = 0;

    // Self-organized role allocation via response thresholds
    this.threshold = {
      dig: 0.1 + Math.random() * 0.8,
      forage: 0.1 + Math.random() * 0.8,
      explore: 0.1 + Math.random() * 0.8,
    };

    this.role = 'idle';
    this.memory = [];
    this.memoryTimer = 0;

    // Tandem running
    this.tandemTarget = null; // ant I'm leading
    this.tandemLeader = null; // ant leading me

    // Antennation
    this.antennateTimer = 0;
    this.antennateTarget = null;

    // AI awareness
    this.lastThought = '';
    this.lastThoughtTime = 0;

    // Vertical body oscillation (sinusoidal for unloaded, jerky for loaded)
    this.bodyBob = 0;
    this.bodyBobPhase = Math.random() * 6.28;

    const names = ['Ada', 'Bo', 'Cal', 'Dee', 'Emi', 'Fay', 'Gil', 'Hal', 'Ira', 'Joy', 'Kai', 'Leo', 'Mae', 'Neo', 'Ora', 'Pip', 'Quinn', 'Rex', 'Sol', 'Tia', 'Uma', 'Val', 'Wren', 'Xia', 'Yui', 'Zoe'];
    this.name = (isQueen ? 'Queen ' : '') + names[this.id % names.length] + '-' + this.id;

    this.size = isQueen ? 4.5 : 3.0 + Math.random() * 0.5;
    this.hue = Math.random() * 15;
    this.legT = Math.random() * 6.28;
    this.antT = Math.random() * 6.28;
  }

  gx() { return (this.x / CELL) | 0; }
  gy() { return (this.y / CELL) | 0; }
  depthR() { return Math.max(0, (this.gy() - SURFACE) / (ROWS - SURFACE)); }
  atSurface() { return this.gy() <= SURFACE + 2; }
  currentSpeed() {
    if (this.isPaused) return 0.05; // still creep slightly during micro-pause
    if (this.state === ST.TANDEM_LEAD) return TANDEM_SPEED;
    return (this.carrying || this.carryingSand > 0) ? LOADED_SPEED : BASE_SPEED;
  }

  sense() {
    const gx = this.gx(), gy = this.gy();
    const s = {
      gx, gy,
      surface: this.atSurface(),
      depth: this.depthR(),
      below: isSolid(gx, gy + 1), above: isSolid(gx, gy - 1),
      left: isSolid(gx - 1, gy), right: isSolid(gx + 1, gy),
      food: null, foodDist: 999,
      trailGrad: phGradient(gx, gy, phTrail, 6),
      foodGrad: phGradient(gx, gy, phFood, 6),
      digGrad: phGradient(gx, gy, phDig, 5),
      trailHere: phGet(gx, gy, phTrail),
      foodHere: phGet(gx, gy, phFood),
      digHere: phGet(gx, gy, phDig),
      nearAnts: 0, nearDiggers: 0, nearForagers: 0,
      wallDir: null,
    };

    for (const f of foods) {
      const d = Math.hypot(f.x - this.x, f.y - this.y);
      if (d < 60 && d < s.foodDist) { s.food = f; s.foodDist = d; }
    }

    for (const a of ants) {
      if (a === this) continue;
      const dist = Math.hypot(a.x - this.x, a.y - this.y);
      if (dist < 25) {
        s.nearAnts++;
        if (a.role === 'digger') s.nearDiggers++;
        if (a.role === 'forager') s.nearForagers++;
      }
      // Antennation: within 1 body length
      if (dist < ANT_BODY_PX && this.antennateTimer <= 0 && Math.random() < 0.01) {
        this.antennateTarget = a;
        this.antennateTimer = 30; // ~0.5 seconds
      }
    }

    if (!s.surface) {
      const wallL = isSolid(gx - 1, gy) ? 1 : 0;
      const wallR = isSolid(gx + 1, gy) ? 1 : 0;
      const wallU = isSolid(gx, gy - 1) ? 1 : 0;
      const wallD = isSolid(gx, gy + 1) ? 1 : 0;
      if (wallL + wallR + wallU + wallD > 0 && wallL + wallR + wallU + wallD < 4) {
        s.wallDir = { l: wallL, r: wallR, u: wallU, d: wallD };
      }
    }

    return s;
  }

  think(s) {
    this.timeSinceRest++;

    // Antennation interaction
    if (this.antennateTimer > 0) {
      this.antennateTimer--;
      if (this.antennateTarget && this.antennateTimer > 20) {
        // Exchange information: share knowledge of food/dig sites
        const other = this.antennateTarget;
        if (this.carrying && other.threshold.forage > 0.5) {
          other.threshold.forage *= 0.8; // encourage foraging
        }
        if (this.role === 'digger' && other.role === 'idle') {
          other.threshold.dig *= 0.85; // recruit digger
        }
      }
      if (this.antennateTimer <= 0) this.antennateTarget = null;
    }

    // Brief micro-pauses — much less frequent so ants feel alive
    if (!this.isPaused && this.state !== ST.REST) {
      this.pauseTimer++;
      if (this.pauseTimer >= this.nextPauseAt) {
        this.isPaused = true;
        this.pauseDuration = 1 + Math.random() * 2; // 1-3 frames (very brief)
        this.pauseTimer = 0;
        this.nextPauseAt = 40 + Math.random() * 60; // pause every 40-100 frames
      }
    }
    if (this.isPaused) {
      this.pauseDuration--;
      if (this.pauseDuration <= 0) this.isPaused = false;
      // Don't return — still think, just don't move
    }

    // Rest cycle
    if (this.timeSinceRest > this.nextRestAt && this.state !== ST.CARRY && this.state !== ST.HAUL_SAND) {
      this.state = ST.REST;
      this.restTimer = 0;
      this.timeSinceRest = 0;
      this.nextRestAt = 180 + Math.random() * 220;
      return;
    }
    if (this.state === ST.REST) {
      this.restTimer++;
      this.energy += 0.6;
      if (this.restTimer > this.restDuration) {
        this.restTimer = 0;
        this.state = ST.WANDER;
      }
      return;
    }

    if (this.energy < 50) { this.state = ST.REST; this.restTimer = 0; return; }
    if (this.isQueen) { this.state = ST.WANDER; return; }

    // Carrying food → return
    if (this.carrying) { this.state = ST.CARRY; return; }

    // Hauling sand → return to surface to deposit
    if (this.carryingSand > 0) { this.state = ST.HAUL_SAND; return; }

    // Tandem running: if I'm leading, continue leading
    if (this.tandemTarget) {
      const dist = Math.hypot(this.tandemTarget.x - this.x, this.tandemTarget.y - this.y);
      if (dist > 80 || this.tandemTarget.energy < 50) {
        // Lost follower
        this.tandemTarget.tandemLeader = null;
        this.tandemTarget = null;
      } else {
        this.state = ST.TANDEM_LEAD;
        return;
      }
    }
    // If I'm following, keep following
    if (this.tandemLeader) {
      if (Math.hypot(this.tandemLeader.x - this.x, this.tandemLeader.y - this.y) > 80) {
        this.tandemLeader.tandemTarget = null;
        this.tandemLeader = null;
      } else {
        this.state = ST.TANDEM_FOLLOW;
        return;
      }
    }

    // Utility-based decision making
    let scores = { dig: 0, forage: 0, explore: 0, rest: 0, wander: 0 };

    const digStim = s.digHere + (s.digGrad.strength * 0.5);
    if (digStim > this.threshold.dig) {
      scores.dig = (digStim - this.threshold.dig) * 3;
      scores.dig *= Math.max(0.1, 1 - s.nearDiggers * 0.25);
    }

    const foodStim = s.foodHere + (s.food ? 0.5 : 0) + s.foodGrad.strength * 0.3;
    if (foodStim > this.threshold.forage) {
      scores.forage = (foodStim - this.threshold.forage) * 4;
      scores.forage *= Math.max(0.1, 1 - s.nearForagers * 0.2);
    }

    const exploreStim = s.trailGrad.strength * 0.3 + (1 - s.depth) * 0.2;
    if (exploreStim > this.threshold.explore * 0.5) {
      scores.explore = exploreStim * 2;
    }

    if (s.surface) scores.wander = 0.5;

    let best = 'wander', bestScore = scores.wander;
    for (const [action, score] of Object.entries(scores)) {
      if (score > bestScore) { bestScore = score; best = action; }
    }

    // On surface
    if (s.surface) {
      if (best === 'forage' && s.food) {
        this.state = ST.FORAGE; this.targetX = s.food.x; this.targetY = s.food.y;
        this.role = 'forager'; return;
      }
      if (best === 'forage' && s.foodGrad.angle !== null) {
        this.state = ST.FORAGE; this.heading = s.foodGrad.angle;
        this.role = 'forager'; return;
      }

      this.patience++;
      const threshold = 80 + (1 - scores.dig) * 120;
      if (this.patience > threshold || best === 'dig') {
        this.patience = 0;
        this.role = 'digger';

        // Stigmergy: strongly prefer existing entrances (85%)
        let bestEntrance = null, bestDist = 200;
        for (let dx = -100; dx <= 100; dx += 2) {
          const ex = this.gx() + dx;
          if (ex >= 2 && ex < COLS - 2 && !cellAt(ex, SURFACE + 1) && !cellAt(ex, SURFACE + 2) && !cellAt(ex, SURFACE + 3)) {
            const d = Math.abs(dx);
            if (d < bestDist) { bestDist = d; bestEntrance = ex; }
          }
        }

        if (bestEntrance !== null && Math.random() < 0.85) {
          this.targetX = bestEntrance * CELL;
          this.state = ST.ENTER;
        } else {
          this.state = ST.DIG_DOWN;
          this.digCount = 0;
          // Dig straight down — real ant farm tunnels start vertical
          this.digAngle = Math.PI * 0.5 + (Math.random() - 0.5) * 0.08;
        }
        return;
      }

      this.state = ST.WANDER; this.role = 'idle';
      return;
    }

    // Underground
    if (this.state === ST.DIG_DOWN || this.state === ST.DIG_BRANCH || this.state === ST.DIG_CHAMBER) {
      // Check if we need to haul sand to surface
      if (this.digCount >= this.maxSandCarry) {
        this.carryingSand = this.digCount;
        this.digCount = 0;
        this.state = ST.HAUL_SAND;
        return;
      }

      if (s.depth > 0.2 + Math.random() * 0.6 && this.state === ST.DIG_DOWN) {
        if (Math.random() < 0.35) {
          this.state = ST.DIG_CHAMBER; this.patience = 0;
        } else if (Math.random() < 0.5) {
          this.state = ST.DIG_BRANCH;
          // Branches go mostly horizontal with slight downward slope
          this.digAngle = (Math.random() < 0.5 ? 0 : Math.PI) + (Math.random() - 0.5) * 0.3 + 0.15;
        } else {
          this.state = ST.EXPLORE;
        }
        return;
      }
      if (this.state === ST.DIG_CHAMBER) {
        this.patience++;
        const maxSize = 120 - s.depth * 60;
        if (this.patience > maxSize) {
          this.state = Math.random() < 0.4 ? ST.GO_UP : ST.EXPLORE;
          this.patience = 0;
          phSet(s.gx, s.gy, 0.8, phDig);
        }
        return;
      }
      if (this.state === ST.DIG_BRANCH) {
        // Piecewise linear tunnel: change direction every 5-15 body lengths
        if (Math.random() < 0.008) this.digAngle += (Math.random() - 0.5) * 0.6;
        if (Math.random() < 0.005) this.state = Math.random() < 0.5 ? ST.GO_UP : ST.EXPLORE;
        return;
      }
      // Dig down: very gentle sway — keep nearly vertical
      if (Math.random() < 0.01) {
        this.digAngle += (Math.random() - 0.5) * 0.15;
        // Clamp close to vertical (PI/2)
        this.digAngle = Math.max(Math.PI * 0.35, Math.min(Math.PI * 0.65, this.digAngle));
      }
      return;
    }

    if (this.state === ST.EXPLORE || this.state === ST.WALL_FOLLOW) {
      if (s.wallDir) this.state = ST.WALL_FOLLOW;
      else this.state = ST.EXPLORE;

      if (s.trailGrad.angle !== null && s.trailGrad.strength > 0.05) {
        this.heading = this.heading * 0.7 + s.trailGrad.angle * 0.3;
      }
      if (s.digGrad.angle !== null && s.digGrad.strength > this.threshold.dig) {
        this.state = ST.DIG_BRANCH;
        this.digAngle = s.digGrad.angle;
        this.role = 'digger';
        return;
      }
      if (Math.random() < 0.003) {
        this.state = scores.dig > 0.3 ? ST.DIG_BRANCH : ST.GO_UP;
        this.digAngle = this.heading + (Math.random() - 0.5) * 1.0;
      }
      return;
    }

    if (this.state === ST.GO_UP || this.state === ST.CARRY || this.state === ST.HAUL_SAND) {
      if (s.surface) {
        if (this.carryingSand > 0) {
          // Deposit sand on surface near entrance, building a visible mound
          for (let i = 0; i < this.carryingSand; i++) {
            depositSandOnSurface(this.gx() + Math.round((Math.random() - 0.5) * 3));
          }
          this.carryingSand = 0;
          // Spawn visible sand-colored particles to show the deposit
          for (let i = 0; i < 6; i++) {
            particles.push({
              x: this.x + (Math.random() - 0.5) * 8,
              y: this.y - 2,
              vx: (Math.random() - 0.5) * 1.5,
              vy: -Math.random() * 0.8 - 0.1,
              life: 30 + Math.random() * 20,
              size: 1.5 + Math.random() * 1.5,
              r: SAND_R, g: SAND_G, b: SAND_B
            });
          }
        }
        this.state = ST.WANDER; this.patience = 0;
        if (this.carrying) this.carrying = false;
        this.role = 'idle';
      }
      return;
    }

    this.state = ST.EXPLORE;
  }

  act(s) {
    this.age++;
    this.experience++;
    this.energy -= 0.1;
    const moving = this.state !== ST.REST && !this.isPaused;
    this.legT += moving ? 0.22 : 0;
    this.antT += 0.07;
    if (this.digCD > 0) this.digCD--;

    // Body oscillation: smooth sine for unloaded, irregular for loaded
    if (moving) {
      this.bodyBobPhase += 0.3;
      if (this.carrying || this.carryingSand > 0) {
        // Loaded: jerky/irregular
        this.bodyBob = Math.sin(this.bodyBobPhase) * 0.4 + Math.sin(this.bodyBobPhase * 2.7) * 0.3;
      } else {
        // Unloaded: smooth sinusoidal
        this.bodyBob = Math.sin(this.bodyBobPhase) * 0.3;
      }
    }

    // Memory
    this.memoryTimer++;
    if (this.memoryTimer > 30) {
      this.memory.push({ x: this.gx(), y: this.gy() });
      if (this.memory.length > 8) this.memory.shift();
      this.memoryTimer = 0;
    }

    // Pheromone deposition
    const gx = s.gx, gy = s.gy;
    if (this.carrying) {
      phSet(gx, gy, 0.3, phFood);
      phSet(gx, gy, 0.2, phTrail);
    } else if (this.carryingSand > 0) {
      phSet(gx, gy, 0.15, phTrail);
    } else if (this.state === ST.DIG_DOWN || this.state === ST.DIG_BRANCH || this.state === ST.DIG_CHAMBER) {
      phSet(gx, gy, 0.25, phDig);
      phSet(gx, gy, 0.15, phTrail);
    } else {
      phSet(gx, gy, 0.06, phTrail);
    }

    const spd = this.currentSpeed();

    switch (this.state) {
      case ST.WANDER: this._wander(s, spd); break;
      case ST.ENTER: this._enter(s, spd); break;
      case ST.DIG_DOWN: case ST.DIG_BRANCH: this._digTunnel(s, spd); break;
      case ST.DIG_CHAMBER: this._digChamber(s, spd); break;
      case ST.EXPLORE: this._explore(s, spd); break;
      case ST.WALL_FOLLOW: this._wallFollow(s, spd); break;
      case ST.GO_UP: case ST.CARRY: case ST.HAUL_SAND: this._goUp(s, spd); break;
      case ST.FORAGE: this._forage(s, spd); break;
      case ST.TANDEM_LEAD: this._tandemLead(s, spd); break;
      case ST.TANDEM_FOLLOW: this._tandemFollow(s, spd); break;
      case ST.REST: break;
    }

    // Food pickup
    if (!this.carrying) {
      for (let i = foods.length - 1; i >= 0; i--) {
        if (Math.hypot(foods[i].x - this.x, foods[i].y - this.y) < CELL * 3) {
          foods[i].amount--;
          if (foods[i].amount <= 0) foods.splice(i, 1);
          this.carrying = true;
          this.energy = Math.min(1100, this.energy + 400);
          this.state = ST.CARRY; this.role = 'forager'; break;
        }
      }
    }
    if (this.carrying && s.surface) { this.carrying = false; this.state = ST.WANDER; this.role = 'idle'; }

    // Physics
    if (!s.below && gy < ROWS - 1) this.vy += 0.2;
    if ((s.left || s.right) && !s.below) this.vy *= 0.35;

    const maxV = spd * 3;
    this.vx = Math.max(-maxV, Math.min(maxV, this.vx));
    this.vy = Math.max(-maxV, Math.min(maxV, this.vy));

    this.px = this.x; this.py = this.y;
    let nx = this.x + this.vx, ny = this.y + this.vy;
    const ngx = (nx / CELL) | 0, ngy = (ny / CELL) | 0;

    const digging = this.state === ST.DIG_DOWN || this.state === ST.DIG_BRANCH || this.state === ST.DIG_CHAMBER;
    if (isSolid(ngx, ngy) && !digging) {
      if (!isSolid(s.gx, ngy)) { nx = this.x; this.vx *= 0.15; }
      else if (!isSolid(ngx, s.gy)) { ny = this.y; this.vy *= 0.15; }
      else { nx = this.x; ny = this.y; this.vx *= 0.05; this.vy *= 0.05; this.stuck++; }
    } else this.stuck = 0;

    if (this.stuck > 12) { this._unstick(s.gx, s.gy); this.stuck = 0; }

    // Clamp to within the frame — ants cannot escape the ant farm
    this.x = Math.max(FRAME + CELL, Math.min(W - FRAME - CELL, nx));
    // Hard ceiling: ants cannot go above the surface area (no flying!)
    const minY = SURFACE_PX - CELL * 5; // small margin above surface for walking
    this.y = Math.max(minY, Math.min(H - FRAME * 2.5 - CELL, ny));
    // If pushed above surface while not on surface, force back down
    if (this.y < SURFACE_PX - CELL * 3 && !this.atSurface()) {
      this.vy = Math.max(this.vy, 0.2);
    }
  }

  // Correlated random walk with natural meandering
  _correlatedWalk(spd, turnRange) {
    const range = turnRange || 0.35; // ~20 degrees per step (research: 10-20°)
    this.heading += (Math.random() - 0.5) * range;

    // Natural meandering: left-right oscillation ~3 body-length wavelength
    this.meanderPhase += this.meanderFreq;
    const meander = Math.sin(this.meanderPhase) * 0.08;
    this.heading += meander;

    // Anti-backtrack
    if (this.memory.length > 2) {
      const last = this.memory[this.memory.length - 1];
      const dx = this.gx() - last.x, dy = this.gy() - last.y;
      if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {
        this.heading += (Math.random() - 0.5) * 2;
      }
    }

    this.vx += Math.cos(this.heading) * spd * 0.45;
    this.vy += Math.sin(this.heading) * spd * 0.45;
  }

  _wander(s, spd) {
    this._correlatedWalk(spd, 0.4);
    // Hard surface constraint — ants walk ON the surface, not above it
    const surfY = SURFACE_PX - CELL;
    if (this.y < surfY - CELL * 2) { this.vy += 0.5; this.y = Math.max(this.y, surfY - CELL * 4); }
    if (this.y < surfY) this.vy += 0.2; // gentle push down to surface
    if (this.y > surfY + CELL * 2) this.vy -= 0.15; // don't sink into dirt
    // Keep within frame bounds
    if (this.x < FRAME + CELL * 2) { this.vx += 0.3; this.heading = 0; }
    if (this.x > W - FRAME - CELL * 2) { this.vx -= 0.3; this.heading = Math.PI; }
    this.vx *= 0.92; this.vy *= 0.92;
  }

  _enter(s, spd) {
    if (this.targetX >= 0) {
      const dx = this.targetX - this.x;
      if (Math.abs(dx) > CELL * 3) {
        // Walk along surface toward entrance
        this.vx += Math.sign(dx) * spd * 0.5;
        this.heading = dx > 0 ? 0 : Math.PI;
        // Keep on surface while walking to entrance
        if (this.y < SURFACE_PX - CELL) this.vy += 0.2;
      } else {
        // At entrance — head down into the tunnel
        this.vy += spd * 0.5;
        this.heading = Math.PI * 0.5;
        this.state = ST.EXPLORE; this.targetX = -1;
      }
    }
    this.vx *= 0.92; this.vy *= 0.92;
  }

  _digTunnel(s, spd) {
    // DIG_DOWN: dig nearly straight down (real tunnel shafts are vertical)
    // DIG_BRANCH: dig horizontally or at slight angles
    const isDrilling = this.state === ST.DIG_DOWN;
    if (isDrilling) {
      // Keep dig angle nearly vertical — clamp strongly toward straight down
      this.digAngle = this.digAngle * 0.95 + (Math.PI * 0.5) * 0.05;
    }

    const dx = Math.cos(this.digAngle), dy = Math.sin(this.digAngle);
    this.heading = this.digAngle;

    this.vx += dx * spd * 0.12;
    this.vy += dy * spd * 0.18;
    this.vx *= 0.8; this.vy *= 0.8;

    if (this.digCD <= 0) {
      const fwdX = s.gx + Math.round(dx * 2), fwdY = s.gy + Math.round(dy * 2);
      if (isSolid(fwdX, fwdY)) {
        const hardness = cellAt(fwdX, fwdY);
        if (hardness >= 5) {
          // Rock — go around it
          this.digAngle += (Math.random() - 0.5) * 0.8;
          this.digCD = 10;
        } else {
          // Dig 1-2 cells — one grain at a time
          let dugCount = 0;
          for (let ddx = -1; ddx <= 1; ddx++) for (let ddy = -1; ddy <= 1; ddy++) {
            if (ddx * ddx + ddy * ddy <= 1 && dugCount < 2) {
              const result = digCell(fwdX + ddx, fwdY + ddy);
              if (result) { dugCount++; this.digCount++; }
            }
          }
          this.digCD = 10 + (hardness * 2) + (Math.random() * 6) | 0;
          this.energy -= 0.4;
          phSet(s.gx, s.gy, 0.4, phDig);
          if (dugCount > 0) spawnDirt(fwdX * CELL, fwdY * CELL);
        }
      } else {
        // Open space ahead — advance into it
        this.vx += dx * spd * 0.3;
        this.vy += dy * spd * 0.3;
        this.digCD = 5;
      }
    }
  }

  _digChamber(s, spd) {
    this.heading += 0.06 + Math.random() * 0.03;
    this.vx += Math.cos(this.heading) * spd * 0.18;
    this.vy += Math.sin(this.heading) * spd * 0.18;
    this.vx *= 0.8; this.vy *= 0.8;

    if (this.digCD <= 0) {
      let dugCount = 0;
      for (let ddx = -2; ddx <= 2; ddx++) for (let ddy = -2; ddy <= 2; ddy++) {
        if (ddx * ddx + ddy * ddy <= 4 && Math.random() < 0.5 && dugCount < 3) {
          const result = digCell(s.gx + ddx, s.gy + ddy);
          if (result) { dugCount++; this.digCount++; }
        }
      }
      this.digCD = 18 + (Math.random() * 12) | 0;
      this.energy -= 0.35;
      if (dugCount > 0) spawnDirt(this.x, this.y);
    }
  }

  _explore(s, spd) {
    // Experienced ants walk straighter (research: narrower angular distribution)
    const turnRange = this.experience > 500 ? 0.25 : 0.6;
    this._correlatedWalk(spd, turnRange);

    const aheadX = s.gx + Math.round(Math.cos(this.heading) * 3);
    const aheadY = s.gy + Math.round(Math.sin(this.heading) * 3);
    if (isSolid(aheadX, aheadY)) {
      this.heading += Math.PI * 0.5 + (Math.random() - 0.5) * 0.5;
      if (this.threshold.dig < 0.3 && this.digCD <= 0 && Math.random() < 0.15) {
        for (let d = -1; d <= 1; d++) for (let e = -1; e <= 1; e++) {
          const r = digCell(aheadX + d, aheadY + e);
          if (r) this.digCount++;
        }
        this.digCD = 12;
      }
    }
    this.vx *= 0.88; this.vy *= 0.88;
  }

  _wallFollow(s, spd) {
    if (!s.wallDir) { this.state = ST.EXPLORE; return; }
    const w = s.wallDir;

    let targetAngle = this.heading;
    if (w.r && !isSolid(s.gx + Math.round(Math.cos(this.heading)), s.gy + Math.round(Math.sin(this.heading)))) {
      // Wall on right, ahead clear — go forward
    } else if (!w.r && !w.d) {
      targetAngle = this.heading + 0.4;
    } else if (isSolid(s.gx + Math.round(Math.cos(this.heading)), s.gy + Math.round(Math.sin(this.heading)))) {
      targetAngle = this.heading - 0.6;
    }

    this.heading = this.heading * 0.8 + targetAngle * 0.2;
    this.vx += Math.cos(this.heading) * spd * 0.4;
    this.vy += Math.sin(this.heading) * spd * 0.4;
    this.vx *= 0.88; this.vy *= 0.88;
  }

  _goUp(s, spd) {
    // Navigate upward through TUNNELS only — don't fly, don't pass through solid
    // Scan for the best open-air direction that leads upward
    let best = -Math.PI / 2, bestS = -999;
    for (let a = -Math.PI; a < Math.PI; a += 0.35) {
      const cx = s.gx + Math.round(Math.cos(a) * 2), cy = s.gy + Math.round(Math.sin(a) * 2);
      if (!isSolid(cx, cy)) {
        // Strongly prefer upward directions, but only through air
        const upBias = -Math.sin(a) * 3.0; // reward upward
        const trailBonus = phGet(cx, cy, phTrail) * 1.0; // follow trails
        const sc = upBias + trailBonus;
        if (sc > bestS) { bestS = sc; best = a; }
      }
    }
    this.heading = this.heading * 0.5 + best * 0.5;
    this.vx += Math.cos(this.heading) * spd * 0.35;
    this.vy += Math.sin(this.heading) * spd * 0.35;
    // Only dig if truly stuck (surrounded by walls) — last resort
    if (this.stuck > 20 && this.digCD <= 0) {
      digCell(s.gx, s.gy - 1); digCell(s.gx, s.gy - 2);
      this.digCD = 8;
    }
    this.vx *= 0.85; this.vy *= 0.85;
  }

  _forage(s, spd) {
    if (this.targetX >= 0 && s.food) {
      const dx = this.targetX - this.x, dy = this.targetY - this.y, d = Math.hypot(dx, dy);
      if (d > 4) {
        this.heading = Math.atan2(dy, dx);
        this.vx += (dx / d) * spd * 0.55;
        this.vy += (dy / d) * spd * 0.55;
      }
    } else if (s.foodGrad.angle !== null) {
      this.heading = this.heading * 0.6 + s.foodGrad.angle * 0.4;
      this.vx += Math.cos(this.heading) * spd * 0.4;
      this.vy += Math.sin(this.heading) * spd * 0.4;
    } else {
      this._correlatedWalk(spd, 0.5);
    }
    this.vx *= 0.9; this.vy *= 0.9;
  }

  // Tandem running: leader moves at 25% speed, waits if follower falls behind
  _tandemLead(s, spd) {
    if (!this.tandemTarget) { this.state = ST.EXPLORE; return; }
    const target = this.tandemTarget;
    const dist = Math.hypot(target.x - this.x, target.y - this.y);

    // Wait if follower falls behind (research: leader slows/pauses)
    if (dist > 30) {
      this.vx *= 0.3; this.vy *= 0.3;
      return;
    }

    // Move toward dig site or deeper underground
    this.vy += spd * 0.15;
    this._correlatedWalk(spd * 0.5, 0.3);
    this.vx *= 0.85; this.vy *= 0.85;

    // End tandem after reaching depth
    if (this.depthR() > 0.3) {
      target.tandemLeader = null;
      target.role = 'digger';
      target.state = ST.DIG_BRANCH;
      target.threshold.dig *= 0.5; // follower learned to dig
      target.experience += 200;
      this.tandemTarget = null;
      this.state = ST.EXPLORE;
    }
  }

  _tandemFollow(s, spd) {
    if (!this.tandemLeader) { this.state = ST.EXPLORE; return; }
    const leader = this.tandemLeader;
    const dx = leader.x - this.x, dy = leader.y - this.y;
    const d = Math.hypot(dx, dy);

    // Follow leader — signal readiness by getting close
    if (d > 8) {
      this.vx += (dx / d) * spd * 0.5;
      this.vy += (dy / d) * spd * 0.5;
    }
    this.vx *= 0.88; this.vy *= 0.88;
    this.experience += 0.5; // learning while following
  }

  _unstick(gx, gy) {
    const seen = new Set(), q = [[gx, gy]]; seen.add(gx + ',' + gy);
    while (q.length) {
      const [cx, cy] = q.shift();
      if (!isSolid(cx, cy) && cy >= 0 && cy < ROWS) {
        this.x = cx * CELL + CELL / 2; this.y = cy * CELL + CELL / 2;
        this.vx = this.vy = 0; return;
      }
      for (const [dx, dy] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
        const nx = cx + dx, ny = cy + dy, k = nx + ',' + ny;
        if (!seen.has(k) && nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
          seen.add(k); q.push([nx, ny]);
        }
      }
      if (seen.size > 300) break;
    }
  }

  update() { const s = this.sense(); this.think(s); this.act(s); }
}

// ═══════════════════════════════════════════════════════════════════
//  PARTICLES
// ═══════════════════════════════════════════════════════════════════

function spawnDirt(x, y) {
  for (let i = 0; i < 4; i++)
    particles.push({
      x: x + Math.random() * CELL, y: y + Math.random() * CELL,
      vx: (Math.random() - 0.5) * 1.2, vy: -Math.random() * 1.0 - 0.2,
      life: 25 + Math.random() * 15, size: 1 + Math.random() * 1.5,
      r: 200 + Math.random() * 30, g: 180 + Math.random() * 20, b: 140 + Math.random() * 20
    });
}

function tickParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.vx *= 0.97;
    if (--p.life <= 0) particles.splice(i, 1);
  }
}

// ═══════════════════════════════════════════════════════════════════
//  RENDERING — Smooth sand with multi-octave noise and SDF edges
// ═══════════════════════════════════════════════════════════════════

const SAND_R = 212, SAND_G = 194, SAND_B = 162;

// Cached terrain image data
let terrainImageData;

function renderTerrain() {
  // Only re-render terrain when it changes
  if (!terrainDirty && terrainImageData) {
    tCtx.putImageData(terrainImageData, 0, 0);
  } else {
    const tImg = tCtx.createImageData(W, H);
    const d = tImg.data;

    // Sky
    for (let y = 0; y < SURFACE_PX; y++) {
      for (let x = 0; x < W; x++) {
        const i = (y * W + x) * 4;
        d[i] = 238; d[i + 1] = 235; d[i + 2] = 228; d[i + 3] = 255;
      }
    }

    // Ground — ONE single uniform sand color everywhere
    for (let py = SURFACE_PX; py < H; py++) {
      const gy = (py / CELL) | 0;
      for (let px = 0; px < W; px++) {
        const gx = (px / CELL) | 0;
        const i = (py * W + px) * 4;
        const v = cellAt(gx, gy);

        if (v > 0) {
          let r = SAND_R, g = SAND_G, b = SAND_B;

          // Only darken at tunnel edges for depth perception
          const af = airFraction(gx, gy);
          if (af > 0 && af < 1) {
            const shadow = af * 0.3;
            r *= (1 - shadow);
            g *= (1 - shadow);
            b *= (1 - shadow);
          }

          d[i] = r | 0;
          d[i + 1] = g | 0;
          d[i + 2] = b | 0;
          d[i + 3] = 255;
        } else {
          // Tunnel interior — uniform dark
          d[i] = 10;
          d[i + 1] = 8;
          d[i + 2] = 6;
          d[i + 3] = 255;
        }
      }
    }

    tCtx.putImageData(tImg, 0, 0);
    terrainImageData = tCtx.getImageData(0, 0, W, H);
    terrainDirty = false;
  }

  // Draw with blur to eliminate cell boundaries / pixelation
  ctx.filter = 'blur(2.5px)';
  ctx.drawImage(tOff, 0, 0);
  ctx.filter = 'none';
  // Overlay sharp version at low opacity for edge definition
  ctx.globalAlpha = 0.25;
  ctx.drawImage(tOff, 0, 0);
  ctx.globalAlpha = 1.0;
}

function renderFrame() {
  const green = '#2d8c3c', greenDark = '#1e6b2b', greenLight = '#3aad4d';
  ctx.fillStyle = green;
  ctx.fillRect(0, 0, W, FRAME); ctx.fillRect(0, H - FRAME * 2.5, W, FRAME * 2.5);
  ctx.fillRect(0, 0, FRAME, H); ctx.fillRect(W - FRAME, 0, FRAME, H);

  const boltR = 5;
  for (const [bx, by] of [[FRAME / 2, FRAME / 2], [W - FRAME / 2, FRAME / 2], [FRAME / 2, H - FRAME * 1.5], [W - FRAME / 2, H - FRAME * 1.5], [FRAME / 2, H * 0.35], [W - FRAME / 2, H * 0.35], [FRAME / 2, H * 0.65], [W - FRAME / 2, H * 0.65]]) {
    ctx.beginPath(); ctx.arc(bx, by, boltR, 0, 6.28); ctx.fillStyle = greenDark; ctx.fill();
    ctx.beginPath(); ctx.arc(bx - 1, by - 1, boltR * 0.6, 0, 6.28); ctx.fillStyle = greenLight; ctx.fill();
  }
  ctx.textAlign = 'center';
  for (let i = 0; i < 7; i++) { ctx.beginPath(); ctx.arc(W * 0.35 + i * 12, FRAME * 0.5, 2, 0, 6.28); ctx.fillStyle = greenDark; ctx.fill(); }
  ctx.strokeStyle = greenLight; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(FRAME, 1); ctx.lineTo(W - FRAME, 1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(1, FRAME); ctx.lineTo(1, H - FRAME * 2.5); ctx.stroke();
  ctx.strokeStyle = greenDark;
  ctx.beginPath(); ctx.moveTo(FRAME, FRAME - 1); ctx.lineTo(W - FRAME, FRAME - 1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W - 2, FRAME); ctx.lineTo(W - 2, H - FRAME * 2.5); ctx.stroke();
}

function renderSilhouette() {
  const y = SURFACE_PX, left = FRAME, right = W - FRAME;
  ctx.save(); ctx.fillStyle = '#2a8a38';
  ctx.fillRect(left, y - 2, right - left, 4);
  ctx.beginPath(); ctx.moveTo(left, y);
  for (let x = left; x <= right; x++) {
    const hill = Math.sin((x - left) * 0.008) * 6 + Math.sin((x - left) * 0.02) * 3;
    ctx.lineTo(x, y - hill - 2);
  }
  ctx.lineTo(right, y); ctx.closePath(); ctx.fill();

  // Barn
  let bx = left + 80;
  ctx.fillRect(bx, y - 30, 35, 28);
  ctx.beginPath(); ctx.moveTo(bx - 3, y - 30); ctx.lineTo(bx + 17, y - 46); ctx.lineTo(bx + 38, y - 30); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#1e6b2b'; ctx.fillRect(bx + 12, y - 16, 10, 14); ctx.fillStyle = '#2a8a38';

  // House
  bx = left + 160;
  ctx.fillRect(bx, y - 25, 28, 23);
  ctx.beginPath(); ctx.moveTo(bx - 2, y - 25); ctx.lineTo(bx + 14, y - 38); ctx.lineTo(bx + 30, y - 25); ctx.closePath(); ctx.fill();
  ctx.fillRect(bx + 22, y - 42, 5, 16);
  ctx.fillStyle = '#1e6b2b'; ctx.fillRect(bx + 8, y - 20, 6, 6); ctx.fillRect(bx + 17, y - 20, 6, 6); ctx.fillStyle = '#2a8a38';

  // Windmill
  const wmX = right - 200;
  ctx.fillRect(wmX, y - 40, 6, 38);
  ctx.save(); ctx.translate(wmX + 3, y - 40); ctx.rotate(frame * 0.008);
  for (let i = 0; i < 4; i++) { ctx.rotate(Math.PI / 2); ctx.fillRect(-2, 0, 4, 18); }
  ctx.restore();

  // Silo
  const sx = right - 120;
  ctx.fillRect(sx, y - 38, 16, 36);
  ctx.beginPath(); ctx.arc(sx + 8, y - 38, 8, Math.PI, 0); ctx.fill();
  ctx.beginPath(); ctx.moveTo(sx + 5, y - 44); ctx.lineTo(sx + 8, y - 52); ctx.lineTo(sx + 11, y - 44); ctx.closePath(); ctx.fill();

  // Big barn
  bx = right - 80;
  ctx.fillRect(bx, y - 32, 40, 30);
  ctx.beginPath(); ctx.moveTo(bx - 3, y - 32); ctx.lineTo(bx + 20, y - 48); ctx.lineTo(bx + 43, y - 32); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#1e6b2b'; ctx.beginPath(); ctx.arc(bx + 20, y - 36, 5, Math.PI, 0); ctx.fill(); ctx.fillStyle = '#2a8a38';

  // Trees
  for (const tx of [left + 30, left + 250, left + 350, right - 260, right - 160]) {
    ctx.fillRect(tx, y - 18, 3, 16); ctx.beginPath(); ctx.arc(tx + 1.5, y - 22, 9, 0, 6.28); ctx.fill();
  }
  // Fence
  for (let fx = left + 300; fx < left + 420; fx += 15) ctx.fillRect(fx, y - 10, 2, 8);
  ctx.fillRect(left + 300, y - 8, 120, 1.5); ctx.fillRect(left + 300, y - 5, 120, 1.5);
  ctx.restore();
}

function renderFood() {
  for (const f of foods) {
    const p = 1 + Math.sin(frame * 0.05) * 0.12, r = 3 + f.amount * 0.8;
    ctx.beginPath(); ctx.arc(f.x, f.y, r * 2 * p, 0, 6.28); ctx.fillStyle = 'rgba(70,170,50,0.06)'; ctx.fill();
    ctx.beginPath(); ctx.arc(f.x, f.y, r * p, 0, 6.28); ctx.fillStyle = 'rgba(90,190,60,0.85)'; ctx.fill();
  }
}

function renderParticles() {
  for (const p of particles) {
    const a = Math.max(0, p.life / 35);
    ctx.fillStyle = `rgba(${p.r | 0},${p.g | 0},${p.b | 0},${a.toFixed(2)})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, 6.28); ctx.fill();
  }
}

// ── Side-view ant rendering (profile view like looking through glass) ──
function renderAnt3D(ant) {
  const x = ant.x, y = ant.y + ant.bodyBob, s = ant.size;
  // Determine facing direction: left (-1) or right (+1) based on horizontal velocity
  const facingRight = ant.vx >= 0 ? 1 : -1;
  const mov = Math.hypot(ant.vx, ant.vy) > 0.08 && !ant.isPaused;

  ctx.save();
  ctx.translate(x, y);
  ctx.scale(facingRight, 1); // flip horizontally if going left

  const br = 42 + ant.hue, bg = 20 + ant.hue * 0.3, bb = 12 + ant.hue * 0.2;

  // === LEGS (3 pairs, side view — only near-side legs visible) ===
  ctx.strokeStyle = `rgb(${br - 8},${bg - 4},${bb - 3})`;
  ctx.lineWidth = 0.6; ctx.lineCap = 'round';

  for (let i = 0; i < 3; i++) {
    const tripodOffset = (i === 1) ? Math.PI : 0;
    const phase = mov ? Math.sin(ant.legT + tripodOffset) : 0;

    // Leg attachment point on body (front, middle, back)
    const attachX = -s * 0.4 + i * s * 0.7;
    const attachY = s * 0.15; // bottom of body

    // Upper leg segment (coxa/femur) — goes down and slightly out
    const kneeX = attachX + phase * s * 0.3;
    const kneeY = attachY + s * 0.7;

    // Lower leg segment (tibia/tarsus) — goes down to ground
    const footX = kneeX + (i - 1) * s * 0.25 + phase * s * 0.4;
    const footY = attachY + s * 1.3 + Math.abs(phase) * s * 0.15;

    ctx.beginPath();
    ctx.moveTo(attachX, attachY);
    ctx.lineTo(kneeX, kneeY);
    ctx.lineTo(footX, footY);
    ctx.stroke();

    // Tiny foot/tarsus hook
    ctx.beginPath();
    ctx.moveTo(footX, footY);
    ctx.lineTo(footX + s * 0.15, footY + s * 0.05);
    ctx.stroke();
  }

  // === ABDOMEN (gaster) — large oval, rear of body ===
  const abdX = -s * 1.0, abdY = -s * 0.1;
  let g = ctx.createRadialGradient(abdX, abdY - s * 0.2, 0, abdX, abdY, s * 0.9);
  g.addColorStop(0, `rgb(${br + 25},${bg + 12},${bb + 6})`);
  g.addColorStop(0.5, `rgb(${br},${bg},${bb})`);
  g.addColorStop(1, `rgb(${br - 12},${bg - 6},${bb - 4})`);
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.ellipse(abdX, abdY, s * 1.0, s * 0.65, -0.1, 0, 6.28); ctx.fill();
  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.beginPath(); ctx.ellipse(abdX + s * 0.1, abdY - s * 0.25, s * 0.4, s * 0.2, -0.2, 0, 6.28); ctx.fill();
  // Segment lines
  ctx.strokeStyle = `rgba(${br - 15},${bg - 8},${bb - 5},0.25)`; ctx.lineWidth = 0.3;
  for (let i = 0; i < 3; i++) {
    const sx2 = abdX - s * 0.4 + i * s * 0.35;
    ctx.beginPath(); ctx.moveTo(sx2, abdY - s * 0.5); ctx.quadraticCurveTo(sx2 + s * 0.05, abdY, sx2, abdY + s * 0.5); ctx.stroke();
  }

  // === PETIOLE (narrow waist) ===
  ctx.fillStyle = `rgb(${br - 5},${bg - 3},${bb - 2})`;
  ctx.beginPath(); ctx.ellipse(-s * 0.1, s * 0.0, s * 0.15, s * 0.12, 0, 0, 6.28); ctx.fill();

  // === THORAX (middle section) ===
  const thX = s * 0.35, thY = -s * 0.05;
  g = ctx.createRadialGradient(thX, thY - s * 0.15, 0, thX, thY, s * 0.5);
  g.addColorStop(0, `rgb(${br + 20},${bg + 10},${bb + 5})`);
  g.addColorStop(0.6, `rgb(${br + 3},${bg + 1},${bb})`);
  g.addColorStop(1, `rgb(${br - 8},${bg - 4},${bb - 3})`);
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.ellipse(thX, thY, s * 0.45, s * 0.35, -0.15, 0, 6.28); ctx.fill();
  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.beginPath(); ctx.ellipse(thX, thY - s * 0.15, s * 0.2, s * 0.1, 0, 0, 6.28); ctx.fill();

  // === HEAD (front, slightly angled down) ===
  const hdX = s * 0.95, hdY = s * 0.05;
  g = ctx.createRadialGradient(hdX, hdY - s * 0.1, 0, hdX, hdY, s * 0.4);
  g.addColorStop(0, `rgb(${br + 15},${bg + 8},${bb + 4})`);
  g.addColorStop(0.6, `rgb(${br},${bg},${bb})`);
  g.addColorStop(1, `rgb(${br - 10},${bg - 5},${bb - 3})`);
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.ellipse(hdX, hdY, s * 0.38, s * 0.32, 0.1, 0, 6.28); ctx.fill();

  // Eye (single eye visible from side view)
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.beginPath(); ctx.arc(hdX + s * 0.18, hdY - s * 0.08, s * 0.08, 0, 6.28); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.beginPath(); ctx.arc(hdX + s * 0.2, hdY - s * 0.1, s * 0.03, 0, 6.28); ctx.fill();

  // === MANDIBLES ===
  ctx.strokeStyle = `rgb(${br - 8},${bg - 4},${bb - 3})`; ctx.lineWidth = 0.7; ctx.lineCap = 'round';
  const mO = mov ? Math.sin(ant.legT * 0.5) * 0.08 : 0;
  // Upper mandible
  ctx.beginPath(); ctx.moveTo(hdX + s * 0.3, hdY - s * 0.05);
  ctx.quadraticCurveTo(hdX + s * 0.55, hdY - s * 0.15 - mO * s, hdX + s * 0.6, hdY - s * 0.02 - mO * s); ctx.stroke();
  // Lower mandible
  ctx.beginPath(); ctx.moveTo(hdX + s * 0.3, hdY + s * 0.1);
  ctx.quadraticCurveTo(hdX + s * 0.55, hdY + s * 0.2 + mO * s, hdX + s * 0.6, hdY + s * 0.08 + mO * s); ctx.stroke();

  // Sand grain in mandibles when hauling
  if (ant.carryingSand > 0) {
    ctx.fillStyle = `rgb(${SAND_R},${SAND_G},${SAND_B})`;
    ctx.beginPath(); ctx.arc(hdX + s * 0.55, hdY + s * 0.03, s * 0.18, 0, 6.28); ctx.fill();
    ctx.fillStyle = `rgba(${SAND_R + 15},${SAND_G + 10},${SAND_B + 5},0.6)`;
    ctx.beginPath(); ctx.arc(hdX + s * 0.52, hdY - s * 0.02, s * 0.08, 0, 6.28); ctx.fill();
  }

  // === ANTENNA (single, side view — curves up and forward) ===
  ctx.lineWidth = 0.5; ctx.strokeStyle = `rgb(${br - 5},${bg - 3},${bb - 2})`;
  const antBob = Math.sin(ant.antT) * 0.15;
  const antExt = ant.antennateTimer > 0 ? 0.25 : 0;
  // Scape (first segment, straight)
  ctx.beginPath(); ctx.moveTo(hdX + s * 0.2, hdY - s * 0.2);
  // Funiculus (curved up and forward)
  ctx.quadraticCurveTo(hdX + s * 0.5, hdY - s * 0.7 + antBob * s,
    hdX + s * (0.8 + antExt), hdY - s * (0.8 - antExt * 0.3) + antBob * s);
  ctx.stroke();
  // Club (tip bulge)
  ctx.fillStyle = `rgb(${br + 5},${bg + 3},${bb + 2})`;
  ctx.beginPath(); ctx.arc(hdX + s * (0.8 + antExt), hdY - s * (0.8 - antExt * 0.3) + antBob * s, s * 0.06, 0, 6.28); ctx.fill();

  // Carrying food
  if (ant.carrying) {
    ctx.fillStyle = 'rgba(80,180,50,0.9)';
    ctx.beginPath(); ctx.arc(hdX + s * 0.5, hdY, s * 0.3, 0, 6.28); ctx.fill();
    ctx.fillStyle = 'rgba(120,220,80,0.4)';
    ctx.beginPath(); ctx.arc(hdX + s * 0.45, hdY - s * 0.08, s * 0.12, 0, 6.28); ctx.fill();
  }

  // Queen marker (larger abdomen already from size, add subtle crown)
  if (ant.isQueen) {
    ctx.fillStyle = 'rgba(255,200,50,0.5)';
    ctx.beginPath(); ctx.arc(abdX, abdY - s * 0.75, s * 0.2, 0, 6.28); ctx.fill();
  }

  // Hover highlight
  if (hoveredAnt === ant) {
    ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 0.8;
    ctx.beginPath(); ctx.ellipse(0, 0, s * 2.5, s * 1.8, 0, 0, 6.28); ctx.stroke();
  }

  ctx.restore();
}

// Tandem running visual: draw line between leader and follower
function renderTandemLines() {
  ctx.strokeStyle = 'rgba(255,200,100,0.15)';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 4]);
  for (const ant of ants) {
    if (ant.tandemTarget) {
      ctx.beginPath();
      ctx.moveTo(ant.x, ant.y);
      ctx.lineTo(ant.tandemTarget.x, ant.tandemTarget.y);
      ctx.stroke();
    }
  }
  ctx.setLineDash([]);
}

function renderGlass() {
  const g = ctx.createLinearGradient(0, 0, W * 0.6, H * 0.4);
  g.addColorStop(0, 'rgba(255,255,255,0.04)'); g.addColorStop(0.4, 'rgba(255,255,255,0)');
  g.addColorStop(0.8, 'rgba(255,255,255,0.02)'); g.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = g; ctx.fillRect(FRAME, FRAME, W - FRAME * 2, H - FRAME * 3.5);
  ctx.save(); ctx.globalAlpha = 0.025; ctx.translate(W * 0.25, 0); ctx.rotate(0.25);
  ctx.fillStyle = '#fff'; ctx.fillRect(-15, 0, 30, H * 1.5); ctx.restore();
}

function render() {
  ctx.clearRect(0, 0, W, H);
  renderTerrain();
  renderSilhouette();
  renderFood();
  renderParticles();
  renderTandemLines();
  for (const ant of ants) renderAnt3D(ant);
  renderFrame();
  renderGlass();
}

// ═══════════════════════════════════════════════════════════════════
//  TOOLTIP
// ═══════════════════════════════════════════════════════════════════

function updateTooltip() {
  if (!running) return;
  const rect = canvas.getBoundingClientRect();
  const sx = W / rect.width, sy = H / rect.height;
  const cx = (mouseX - rect.left) * sx, cy = (mouseY - rect.top) * sy;
  hoveredAnt = null; let closest = 15;
  for (const ant of ants) {
    const d = Math.hypot(ant.x - cx, ant.y - cy);
    if (d < closest) { closest = d; hoveredAnt = ant; }
  }
  if (hoveredAnt) {
    const a = hoveredAnt;
    document.getElementById('ttName').textContent = a.name;
    document.getElementById('ttState').textContent = ST_NAMES[a.state] + (a.isPaused ? ' (paused)' : '');
    document.getElementById('ttEnergy').textContent = Math.round(a.energy);
    document.getElementById('ttAge').textContent = Math.round(a.age / 60) + 's';
    document.getElementById('ttRole').textContent = a.role + (a.isQueen ? ' (queen)' : '') + (a.carryingSand > 0 ? ' [hauling]' : '');
    document.getElementById('ttThought').textContent = a.lastThought || '—';
    tooltip.classList.add('show');
    tooltip.style.left = (mouseX + 16) + 'px'; tooltip.style.top = (mouseY - 12) + 'px';
  } else tooltip.classList.remove('show');
}
document.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; updateTooltip(); });

// ═══════════════════════════════════════════════════════════════════
//  GAME LOOP
// ═══════════════════════════════════════════════════════════════════

function tick() {
  if (!paused) {
    for (let s = 0; s < speed; s++) {
      for (const ant of ants) ant.update();
      if (frame % 3 === 0) gravity();
      if (frame % 8 === 0) phDecay();
      tickParticles();
      for (let i = ants.length - 1; i >= 0; i--) if (ants[i].energy <= 0) ants.splice(i, 1);

      // Queen spawns new ant occasionally
      if (hasQueen && frame % 1800 === 0 && ants.length < 60) {
        const queen = ants.find(a => a.isQueen);
        if (queen) {
          ants.push(new Ant(queen.x + (Math.random() - 0.5) * 10, queen.y));
        }
      }

      // AI awareness pass every ~60 seconds
      if (frame - lastAITick >= AI_INTERVAL) {
        aiAwarenessPass();
        lastAITick = frame;
      }

      frame++;
      simDay = 1 + (frame / 3600) | 0;
    }
    if (frame % 250 === 0) detectChambers();
  }
  render();
  updateHUD();
  requestAnimationFrame(tick);
}

// ═══════════════════════════════════════════════════════════════════
//  UI
// ═══════════════════════════════════════════════════════════════════

function updateHUD() {
  const pct = (totalDug / ((ROWS - SURFACE) * COLS) * 100).toFixed(1);
  document.getElementById('sAnts').textContent = ants.length;
  document.getElementById('sTunnel').textContent = pct + '%';
  document.getElementById('sChambers').textContent = chambers.length;
  document.getElementById('sDay').textContent = simDay;
}

function dropAnts(n) {
  for (let i = 0; i < n; i++) ants.push(new Ant(Math.random() * (W - 80) + 40, (SURFACE - 1) * CELL));
  if (!hasQueen && ants.length > 0) {
    const q = new Ant(W / 2, (SURFACE - 1) * CELL, true);
    ants.push(q);
    hasQueen = true;
  }
  toast(n + ' ant' + (n > 1 ? 's' : '') + ' released');
}

function dropFood() {
  foods.push({ x: Math.random() * (W - 60) + 30, y: SURFACE_PX - CELL * 2, amount: 4 + (Math.random() * 5) | 0 });
  toast('Food placed');
}

function cycleSpeed() {
  const s = [1, 2, 4, 8]; speed = s[(s.indexOf(speed) + 1) % s.length];
  document.getElementById('speedLabel').textContent = speed + 'x'; toast('Speed: ' + speed + 'x');
}

function togglePause() {
  paused = !paused; document.getElementById('pauseBtn').textContent = paused ? 'play' : 'pause';
  toast(paused ? 'Paused' : 'Resumed');
}

function toast(msg) {
  const el = document.getElementById('toast'); el.textContent = msg; el.classList.add('show');
  clearTimeout(el._t); el._t = setTimeout(() => el.classList.remove('show'), 1800);
}

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect(); const sx = W / rect.width, sy = H / rect.height;
  const x = (e.clientX - rect.left) * sx, y = (e.clientY - rect.top) * sy;
  const gx = (x / CELL) | 0, gy = (y / CELL) | 0;
  if (x < FRAME || x > W - FRAME || y < FRAME || y > H - FRAME * 2.5) return;
  if (gy <= SURFACE + 2) { ants.push(new Ant(x, Math.min(y, SURFACE_PX - 2))); toast('Ant dropped'); }
  else { const r = 4; for (let dy = -r; dy <= r; dy++) for (let dx = -r; dx <= r; dx++) if (dx * dx + dy * dy <= r * r) digCell(gx + dx, gy + dy); spawnDirt(x, y); }
});

function begin() {
  document.getElementById('intro').classList.add('hide');
  setTimeout(() => {
    document.getElementById('intro').style.display = 'none';
    document.getElementById('app').classList.add('show');
    canvas.width = W; canvas.height = H; resizeCanvas();
    genSandNoise(); initTerrain(); dropAnts(8);
    running = true; tick();
  }, 500);
}

function resizeCanvas() {
  const wrap = document.getElementById('wrap'); const ww = wrap.clientWidth, wh = wrap.clientHeight;
  const aspect = W / H, wrapAspect = ww / wh;
  let cw, ch;
  if (wrapAspect > aspect) { ch = wh; cw = wh * aspect; } else { cw = ww; ch = ww / aspect; }
  canvas.style.width = cw + 'px'; canvas.style.height = ch + 'px';
}
window.addEventListener('resize', () => { if (running) resizeCanvas(); });
</script>
</body>
</html>
