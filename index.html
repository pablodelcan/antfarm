<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Antfarm</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;1,400&family=Inter:wght@300;400;500&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #fff; color: #1a1a1a;
    font-family: 'Inter', -apple-system, sans-serif;
    height: 100vh; overflow: hidden; -webkit-font-smoothing: antialiased;
  }
  .intro {
    position: fixed; inset: 0; background: #fff;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 100; transition: opacity 0.8s ease;
  }
  .intro.hide { opacity: 0; pointer-events: none; }
  .intro h1 { font-family: 'EB Garamond', serif; font-size: clamp(2.5rem, 5vw, 4.5rem); font-weight: 400; margin-bottom: 12px; }
  .intro h1 em { font-style: italic; }
  .intro .sub { color: #999; font-size: 0.82rem; letter-spacing: 0.08em; margin-bottom: 12px; }
  .intro .sub2 { color: #bbb; font-size: 0.7rem; letter-spacing: 0.06em; margin-bottom: 48px; }
  .intro button {
    background: none; border: 1px solid #ddd; color: #1a1a1a;
    font-family: 'Inter', sans-serif; font-size: 0.78rem; letter-spacing: 0.14em;
    text-transform: uppercase; padding: 14px 44px; cursor: pointer; transition: all 0.3s;
  }
  .intro button:hover { border-color: #1a1a1a; background: #1a1a1a; color: #fff; }
  .app { display: none; height: 100vh; flex-direction: column; }
  .app.show { display: flex; }
  .topbar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 24px; height: 48px; flex-shrink: 0; border-bottom: 1px solid #eee;
  }
  .topbar .title { font-family: 'EB Garamond', serif; font-size: 1.15rem; font-weight: 400; }
  .topbar .title em { font-style: italic; }
  .topbar .stats { display: flex; gap: 24px; font-size: 0.72rem; color: #999; letter-spacing: 0.04em; }
  .topbar .stats .v { color: #1a1a1a; font-weight: 500; margin-left: 6px; font-variant-numeric: tabular-nums; }

  /* ── Intelligence Indicator (top bar) ── */
  .intel-bar {
    display: flex; align-items: center; gap: 0;
    height: 36px; flex-shrink: 0;
    border-bottom: 1px solid #eee; background: #fafaf8;
    padding: 0 24px; overflow: hidden;
    opacity: 0; transition: opacity 0.6s ease;
  }
  .intel-bar.show { opacity: 1; }
  .intel-brain {
    display: flex; align-items: center; gap: 8px;
    font-size: 0.62rem; color: #bbb; letter-spacing: 0.08em;
    text-transform: uppercase; white-space: nowrap; flex-shrink: 0;
  }
  .intel-brain .brain-icon {
    width: 16px; height: 16px; position: relative; display: flex; align-items: center; justify-content: center;
  }
  .intel-brain .brain-dot {
    width: 6px; height: 6px; border-radius: 50%; background: #c084fc;
    animation: brain-pulse 2.5s ease-in-out infinite;
  }
  .intel-brain .brain-ring {
    position: absolute; inset: 0; border: 1.5px solid rgba(192,132,252,0.3);
    border-radius: 50%; animation: brain-ring 2.5s ease-in-out infinite;
  }
  @keyframes brain-pulse { 0%, 100% { opacity: 0.6; transform: scale(0.85); } 50% { opacity: 1; transform: scale(1.15); } }
  @keyframes brain-ring { 0%, 100% { opacity: 0.2; transform: scale(0.8); } 50% { opacity: 0.5; transform: scale(1.2); } }
  .intel-divider {
    width: 1px; height: 16px; background: #e8e4de; margin: 0 14px; flex-shrink: 0;
  }
  .intel-focus {
    font-family: 'EB Garamond', serif; font-size: 0.85rem;
    color: #1a1a1a; font-style: italic; white-space: nowrap;
    flex-shrink: 0;
  }
  .intel-roles {
    font-size: 0.6rem; color: #aaa; letter-spacing: 0.03em;
    font-variant-numeric: tabular-nums; white-space: nowrap; flex-shrink: 0;
    margin-left: 14px;
  }
  .intel-roles .role-count { color: #777; font-weight: 500; }
  .intel-narration {
    font-family: 'EB Garamond', serif; font-size: 0.78rem;
    color: #999; font-style: italic; margin-left: auto;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    max-width: 380px; padding-left: 14px;
  }
  .canvas-wrap {
    flex: 1; position: relative; overflow: hidden;
    background: #e8e0d4; cursor: crosshair;
    display: flex; align-items: center; justify-content: center;
  }
  .canvas-wrap canvas { display: block; }
  .ant-tooltip {
    position: fixed; pointer-events: none;
    background: rgba(255,255,255,0.95); backdrop-filter: blur(8px);
    border: 1px solid #e0e0e0; padding: 8px 12px;
    font-size: 0.68rem; line-height: 1.5; color: #555;
    z-index: 50; opacity: 0; transition: opacity 0.15s ease; max-width: 220px; white-space: nowrap;
  }
  .ant-tooltip.show { opacity: 1; }
  .ant-tooltip .tt-name { color: #1a1a1a; font-weight: 500; margin-bottom: 2px; font-size: 0.72rem; }
  .ant-tooltip .tt-row { display: flex; justify-content: space-between; gap: 12px; }
  .ant-tooltip .tt-val { color: #1a1a1a; font-weight: 500; }
  .bottombar {
    display: flex; align-items: center; justify-content: center; gap: 1px;
    height: 32px; flex-shrink: 0; border-top: 1px solid #eee; background: #fff;
  }
  .bottombar .status {
    font-size: 0.62rem; color: #bbb; letter-spacing: 0.04em;
    padding: 0 20px; display: flex; align-items: center; gap: 6px;
  }
  .bottombar .status .dot {
    width: 5px; height: 5px; border-radius: 50%; background: #4ade80;
    animation: pulse 2s infinite;
  }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
  .toast {
    position: fixed; bottom: 48px; left: 50%; transform: translateX(-50%) translateY(8px);
    background: #1a1a1a; color: #fff; padding: 8px 20px; font-size: 0.72rem;
    opacity: 0; transition: all 0.25s ease; z-index: 90; pointer-events: none;
  }
  .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

  /* ── AI Intelligence Panel (hidden — replaced by intel-bar) ── */
  .ai-panel { display: none; }

  /* ── Hidden Admin Panel ── */
  .admin-panel {
    position: fixed; bottom: 44px; left: 50%; transform: translateX(-50%);
    background: rgba(20,20,20,0.95); backdrop-filter: blur(10px);
    border: 1px solid #333; padding: 12px 20px;
    display: none; align-items: center; gap: 16px;
    z-index: 80; border-radius: 6px;
  }
  .admin-panel.show { display: flex; }
  .admin-panel button {
    background: #333; color: #ddd; border: 1px solid #555;
    font-family: 'Inter', sans-serif; font-size: 0.65rem;
    padding: 6px 14px; cursor: pointer; transition: all 0.2s;
    letter-spacing: 0.04em; text-transform: uppercase;
  }
  .admin-panel button:hover { background: #555; color: #fff; }
  .admin-panel .speed-ctrl {
    display: flex; align-items: center; gap: 8px; color: #aaa; font-size: 0.62rem;
  }
  .admin-panel input[type="range"] {
    width: 80px; accent-color: #4ade80;
  }
</style>
</head>
<body>

<div class="intro" id="intro">
  <h1><em>Antfarm</em></h1>
  <p class="sub">a living colony simulation</p>
  <p class="sub2">guided by Claude AI — shared with everyone</p>
  <button onclick="begin()">Enter</button>
</div>

<div class="app" id="app">
  <div class="topbar">
    <div class="title"><em>Antfarm</em></div>
    <div class="stats">
      <span>Population<span class="v" id="sAnts">0</span></span>
      <span>Tunneled<span class="v" id="sTunnel">0%</span></span>
      <span>Chambers<span class="v" id="sChambers">0</span></span>
      <span>Day<span class="v" id="sDay">1</span></span>
    </div>
  </div>
  <div class="intel-bar" id="intelBar">
    <div class="intel-brain">
      <div class="brain-icon">
        <div class="brain-dot"></div>
        <div class="brain-ring"></div>
      </div>
      <span>Claude AI</span>
    </div>
    <div class="intel-divider"></div>
    <div class="intel-focus" id="intelFocus">Waiting for directive...</div>
    <div class="intel-roles" id="intelRoles"></div>
    <div class="intel-narration" id="intelNarration"></div>
  </div>
  <div class="canvas-wrap" id="wrap">
    <canvas id="c"></canvas>
  </div>
  <div class="bottombar">
    <div class="status">
      <span class="dot"></span>
      <span id="statusText">Connecting...</span>
    </div>
  </div>
</div>

<div class="ant-tooltip" id="tooltip">
  <div class="tt-name" id="ttName"></div>
  <div class="tt-row"><span>State</span><span class="tt-val" id="ttState"></span></div>
  <div class="tt-row"><span>Energy</span><span class="tt-val" id="ttEnergy"></span></div>
  <div class="tt-row"><span>Role</span><span class="tt-val" id="ttRole"></span></div>
  <div class="tt-row"><span>Thought</span><span class="tt-val" id="ttThought"></span></div>
</div>
<div class="toast" id="toast"></div>

<!-- Intelligence Panel -->
<div class="ai-panel" id="aiPanel">
  <div class="ai-label">Colony Intelligence</div>
  <div class="ai-focus" id="aiFocus">—</div>
  <div class="ai-roles" id="aiRoles">—</div>
  <div class="ai-narration" id="aiNarration"></div>
</div>

<!-- Hidden Admin Panel (j+k+l) -->
<div class="admin-panel" id="adminPanel">
  <button onclick="adminAction('addAnts')">+5 Ants</button>
  <button onclick="adminAction('dropFood')">Drop Food</button>
  <button id="pauseBtn" onclick="adminAction('togglePause')">Pause</button>
  <div class="speed-ctrl">
    <span>Speed</span>
    <input type="range" id="speedSlider" min="1" max="5" value="1" oninput="adminAction('setSpeed', this.value)">
    <span id="speedVal">1x</span>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════
//  ANTFARM v9 — Viewer Client
//  Fetches colony state from /api/state every 3 seconds
//  Renders ants + terrain with smooth interpolation
//  All simulation runs server-side — this is purely a renderer
// ═══════════════════════════════════════════════════════════════════

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

// ── Constants (must match server) ──
const W = 960, H = 680;
const CELL = 3;
const COLS = W / CELL, ROWS = Math.ceil(H / CELL);
const SURFACE = Math.round(ROWS * 0.27);
const SURFACE_PX = SURFACE * CELL;
const FRAME = 14;
const SAND_R = 212, SAND_G = 194, SAND_B = 162;

// ── State Names ──
const ST_NAMES = [
  'Wandering', 'Entering', 'Digging down', 'Branching', 'Carving chamber',
  'Exploring', 'Returning', 'Foraging', 'Carrying food', 'Resting', 'Wall following',
  'Hauling sand', 'Leading', 'Following', 'Communicating', 'Pausing', 'Navigating to dig site'
];

// ── Viewer State ──
let grid = null;
let prevGrid = null;          // Previous grid for terrain diff particles
let ants = [];
let antsTarget = [];
let antsPrev = [];
let foods = [];
let chambers = [];
let particles = [];
let terrainParticles = [];     // Particles from terrain diff (dug/deposited)
let fallingObjects = [];       // Client-side falling animation (ants/food dropping in)
let frame = 0, totalDug = 0, simDay = 1;
let running = false;
let hoveredAnt = null, mouseX = 0, mouseY = 0;
let terrainDirty = true;
let lastNarration = '';
let lastFetchTime = 0;
let interpolateT = 0;
let currentDirective = null;
let currentRoleCounts = null;
const POLL_INTERVAL = 3000;
const INTERP_SPEED = 1.0 / (POLL_INTERVAL / 16.67);
const MAX_TERRAIN_PARTICLES = 500;

// ── Offscreen terrain canvas ──
const tOff = document.createElement('canvas');
tOff.width = W; tOff.height = H;
const tCtx = tOff.getContext('2d');
let terrainImageData;

// ── Pixel noise hash (fast deterministic) ──
function pixelHash(x, y) {
  let h = (x * 374761393 + y * 668265263 + 1013904223) | 0;
  h = (h ^ (h >> 13)) * 1274126177;
  return ((h ^ (h >> 16)) & 0xFF) / 255;
}

// ═══════════════════════════════════════════════════════════════════
//  BASE64 DECODE
// ═══════════════════════════════════════════════════════════════════

function base64ToUint8(b64) {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return arr;
}

// ═══════════════════════════════════════════════════════════════════
//  SERVER STATE FETCHING
// ═══════════════════════════════════════════════════════════════════

async function fetchState() {
  try {
    const res = await fetch('/api/state');
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();

    if (data.status === 'initializing') {
      document.getElementById('statusText').textContent = 'Initializing...';
      return;
    }

    // Decode grid and track terrain changes
    if (data.grid && typeof data.grid === 'string') {
      const newGrid = base64ToUint8(data.grid);
      if (grid) {
        prevGrid = grid;
        spawnTerrainDiffParticles(prevGrid, newGrid);
      }
      grid = newGrid;
      terrainDirty = true;
    }

    totalDug = data.totalDug || 0;
    simDay = data.simDay || 1;
    frame = data.frame || 0;
    foods = data.foods || [];
    chambers = data.chambers || [];

    // Save previous ant positions for interpolation
    antsPrev = ants.map(a => ({ ...a }));

    antsTarget = (data.ants || []).map(a => ({
      id: a.id,
      x: a.x, y: a.y,
      vx: a.vx, vy: a.vy,
      state: a.state,
      role: a.role,
      isQueen: a.isQueen,
      carrying: a.carrying,
      carryingSand: a.carryingSand,
      size: a.size,
      hue: a.hue,
      legT: a.legT,
      antT: a.antT,
      bodyBob: a.bodyBob,
      isPaused: a.isPaused,
      antennateTimer: a.antennateTimer,
      name: a.name,
      energy: a.energy,
      age: a.age || 0,
      lastThought: a.lastThought || '',
      tandemTargetId: a.tandemTargetId,
      heading: a.heading || 0
    }));

    if (antsPrev.length === 0) {
      ants = antsTarget.map(a => ({ ...a }));
    } else {
      const prevMap = {};
      for (const a of antsPrev) prevMap[a.id] = a;
      ants = antsTarget.map(a => {
        const prev = prevMap[a.id];
        if (prev) {
          return { ...a, x: prev.x, y: prev.y, legT: prev.legT, antT: prev.antT, bodyBob: prev.bodyBob };
        }
        return { ...a };
      });
    }
    interpolateT = 0;

    // Intelligence panel data
    if (data.directive) {
      currentDirective = data.directive;
      updateAIPanel(data.directive, data.roleCounts);
    }
    if (data.roleCounts) {
      currentRoleCounts = data.roleCounts;
    }

    // Narration
    if (data.narration && data.narration !== lastNarration) {
      lastNarration = data.narration;
      document.getElementById('aiNarration').textContent = data.narration;
    }

    document.getElementById('statusText').textContent = 'Day ' + simDay;
    lastFetchTime = Date.now();

  } catch (err) {
    console.error('Fetch error:', err);
    document.getElementById('statusText').textContent = 'Reconnecting...';
  }
}

// ═══════════════════════════════════════════════════════════════════
//  AI INTELLIGENCE PANEL
// ═══════════════════════════════════════════════════════════════════

const FOCUS_LABELS = {
  extend_shaft: 'Extending main shaft',
  extend_gallery: 'Widening galleries',
  dig_chamber: 'Carving new chamber',
  forage: 'Foraging for food',
  rest: 'Colony resting',
  explore: 'Exploring new paths'
};

function updateAIPanel(directive, roleCounts) {
  const panel = document.getElementById('aiPanel');
  panel.classList.add('show');

  const focusText = FOCUS_LABELS[directive.focus] || directive.focus;
  document.getElementById('aiFocus').textContent = focusText;

  if (roleCounts) {
    document.getElementById('aiRoles').textContent =
      'D:' + roleCounts.digger + '  F:' + roleCounts.forager +
      '  E:' + roleCounts.explorer + '  I:' + roleCounts.idle;
  }

  if (directive.narration) {
    document.getElementById('aiNarration').textContent = directive.narration;
  }

  // ── Update top intelligence bar ──
  const intelBar = document.getElementById('intelBar');
  intelBar.classList.add('show');
  document.getElementById('intelFocus').textContent = focusText;

  if (roleCounts) {
    const total = roleCounts.digger + roleCounts.forager + roleCounts.explorer + roleCounts.idle;
    document.getElementById('intelRoles').innerHTML =
      '<span class="role-count">' + roleCounts.digger + '</span> digging · ' +
      '<span class="role-count">' + roleCounts.forager + '</span> foraging · ' +
      '<span class="role-count">' + roleCounts.explorer + '</span> exploring · ' +
      '<span class="role-count">' + roleCounts.idle + '</span> idle';
  }

  if (directive.narration) {
    document.getElementById('intelNarration').textContent = '"' + directive.narration + '"';
  }
}

// ═══════════════════════════════════════════════════════════════════
//  TERRAIN DIFF PARTICLES
// ═══════════════════════════════════════════════════════════════════

function spawnTerrainDiffParticles(oldGrid, newGrid) {
  if (terrainParticles.length > MAX_TERRAIN_PARTICLES) return;

  let spawned = 0;
  for (let gy = SURFACE; gy < ROWS && spawned < 80; gy++) {
    for (let gx = 0; gx < COLS && spawned < 80; gx++) {
      const i = gy * COLS + gx;
      const wassolid = oldGrid[i] > 0;
      const issolid = newGrid[i] > 0;

      if (wassolid && !issolid && Math.random() < 0.3) {
        // Cell was dug — spawn falling sand particles
        const px = gx * CELL + Math.random() * CELL;
        const py = gy * CELL + Math.random() * CELL;
        terrainParticles.push({
          x: px, y: py,
          vx: (Math.random() - 0.5) * 1.2,
          vy: Math.random() * -1.5 - 0.5,
          life: 40 + Math.random() * 30,
          size: 1.0 + Math.random() * 1.5,
          r: SAND_R + (Math.random() - 0.5) * 20,
          g: SAND_G + (Math.random() - 0.5) * 15,
          b: SAND_B + (Math.random() - 0.5) * 10,
          type: 'dug'
        });
        spawned++;
      } else if (!wassolid && issolid && Math.random() < 0.2) {
        // Cell was filled — spawn settling particles
        const px = gx * CELL + Math.random() * CELL;
        const py = gy * CELL - 2;
        terrainParticles.push({
          x: px, y: py,
          vx: (Math.random() - 0.5) * 0.5,
          vy: Math.random() * 0.8 + 0.3,
          life: 25 + Math.random() * 20,
          size: 0.8 + Math.random() * 1.0,
          r: SAND_R - 10,
          g: SAND_G - 8,
          b: SAND_B - 5,
          type: 'deposit'
        });
        spawned++;
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════════════
//  INTERPOLATION
// ═══════════════════════════════════════════════════════════════════

function interpolateAnts() {
  interpolateT = Math.min(1, interpolateT + INTERP_SPEED);

  for (let i = 0; i < ants.length; i++) {
    const ant = ants[i];
    const target = antsTarget.find(a => a.id === ant.id);
    if (!target) continue;

    ant.x += (target.x - ant.x) * 0.08;
    ant.y += (target.y - ant.y) * 0.08;

    ant.state = target.state;
    ant.role = target.role;
    ant.carrying = target.carrying;
    ant.carryingSand = target.carryingSand;
    ant.isPaused = target.isPaused;
    ant.antennateTimer = target.antennateTimer;
    ant.lastThought = target.lastThought;
    ant.energy = target.energy;
    ant.heading = target.heading;

    const moving = Math.hypot(target.vx, target.vy) > 0.08;
    const posture = getAntPosture(ant);

    if (moving || posture.animateWhenStill) {
      ant.legT += 0.35 * posture.legSpeed;
      ant.antT += 0.08 * posture.antennaSpeed;
      ant.bodyBob = Math.sin(ant.legT * 0.4) * 0.3;
    }

    // Hauling trail particles
    if (ant.carryingSand > 0 && moving && Math.random() < 0.08) {
      const behind = ant.vx >= 0 ? -1 : 1;
      particles.push({
        x: ant.x + behind * ant.size * 1.5,
        y: ant.y + ant.size * 0.8,
        vx: (Math.random() - 0.5) * 0.3,
        vy: Math.random() * 0.5 + 0.1,
        life: 20 + Math.random() * 15,
        size: 0.6 + Math.random() * 0.6,
        r: SAND_R - 10, g: SAND_G - 8, b: SAND_B - 5
      });
    }

    ant.vx = target.vx;
    ant.vy = target.vy;
  }
}

// ═══════════════════════════════════════════════════════════════════
//  ANT POSTURE SYSTEM — Visual differences based on activity state
// ═══════════════════════════════════════════════════════════════════

function getAntPosture(ant) {
  const s = ant.state;
  // Digging states: DIG_DOWN=2, DIG_BRANCH=3, DIG_CHAMBER=4, DIG_TO_TARGET=16
  if (s === 2 || s === 3 || s === 4 || s === 16) {
    return {
      bodyTilt: -0.35 - Math.sin(Date.now() * 0.008) * 0.1,    // Tilted downward, rhythmic
      legSpeed: 1.5,                                              // Faster legs
      mandibleOpen: 0.25 + Math.sin(Date.now() * 0.012) * 0.15, // Chomping
      headDip: 0.3,                                               // Head dipping toward ground
      abdomenPulse: 1.0 + Math.sin(Date.now() * 0.006) * 0.08,  // Slight pulse
      antennaSpeed: 1.2,
      animateWhenStill: true,
      dustChance: 0.15   // Spawn dig dust
    };
  }
  // Hauling sand (11) or Carrying food (8)
  if (s === 11 || s === 8) {
    return {
      bodyTilt: 0.15,          // Leaning back (heavy load)
      legSpeed: 0.6,           // Slower, labored
      mandibleOpen: 0,         // Clamped shut
      headDip: -0.2,           // Head tilted up
      abdomenPulse: 1.0,
      antennaSpeed: 0.7,
      animateWhenStill: false,
      dustChance: 0
    };
  }
  // Resting (9)
  if (s === 9) {
    return {
      bodyTilt: 0,
      legSpeed: 0,             // Legs still
      mandibleOpen: 0,
      headDip: 0.1,            // Head tucked
      abdomenPulse: 1.0 + Math.sin(Date.now() * 0.003) * 0.05, // Breathing
      antennaSpeed: 0.3,       // Very slow antenna
      animateWhenStill: true,
      dustChance: 0
    };
  }
  // Exploring (5, 10)
  if (s === 5 || s === 10) {
    return {
      bodyTilt: -0.05,
      legSpeed: 1.1,
      mandibleOpen: 0.02,
      headDip: 0,
      abdomenPulse: 1.0,
      antennaSpeed: 2.0,       // Very active antenna
      animateWhenStill: false,
      dustChance: 0
    };
  }
  // Default (wander, enter, forage, etc.)
  return {
    bodyTilt: 0,
    legSpeed: 1.0,
    mandibleOpen: 0,
    headDip: 0,
    abdomenPulse: 1.0,
    antennaSpeed: 1.0,
    animateWhenStill: false,
    dustChance: 0
  };
}

// ═══════════════════════════════════════════════════════════════════
//  TERRAIN HELPERS
// ═══════════════════════════════════════════════════════════════════

function cellAt(x, y) {
  return (x < 0 || x >= COLS || y < 0 || y >= ROWS) ? 255 : grid[y * COLS + x];
}

function isSolid(x, y) { return cellAt(x, y) > 0; }

// ═══════════════════════════════════════════════════════════════════
//  PARTICLES
// ═══════════════════════════════════════════════════════════════════

function tickParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.vx *= 0.97;
    if (--p.life <= 0) particles.splice(i, 1);
  }
  // Terrain diff particles
  for (let i = terrainParticles.length - 1; i >= 0; i--) {
    const p = terrainParticles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.08; p.vx *= 0.96;
    if (--p.life <= 0) terrainParticles.splice(i, 1);
  }
  // Falling objects (visual-only drop-in animation)
  for (let i = fallingObjects.length - 1; i >= 0; i--) {
    const f = fallingObjects[i];
    f.vy += 0.25; // gravity
    f.y += f.vy;
    f.x += f.vx;
    f.vx *= 0.99;
    f.rotation += f.rotSpeed;
    // Bounce off surface
    if (f.y > SURFACE_PX - 5) {
      f.y = SURFACE_PX - 5;
      f.vy *= -0.3;
      if (Math.abs(f.vy) < 0.5) {
        fallingObjects.splice(i, 1);
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════════════
//  RENDERING — Smooth sand with pixel noise, depth gradient, strata
// ═══════════════════════════════════════════════════════════════════

function renderTerrain() {
  if (!grid) return;

  if (!terrainDirty && terrainImageData) {
    tCtx.putImageData(terrainImageData, 0, 0);
  } else {
    const tImg = tCtx.createImageData(W, H);
    const d = tImg.data;
    const depthRange = H - SURFACE_PX;

    // Sky
    for (let y = 0; y < SURFACE_PX; y++) {
      for (let x = 0; x < W; x++) {
        const i = (y * W + x) * 4;
        d[i] = 238; d[i + 1] = 235; d[i + 2] = 228; d[i + 3] = 255;
      }
    }

    // Ground — pixel-level rendering with noise, depth, strata, bilinear edges
    for (let py = SURFACE_PX; py < H; py++) {
      const gy = (py / CELL) | 0;
      const gyFrac = (py / CELL) - gy; // Fractional cell position (for bilinear)
      const depthFactor = (py - SURFACE_PX) / depthRange; // 0 at surface, 1 at bottom

      // Strata banding — subtle horizontal color shifts
      const strataShift = Math.sin(py * 0.08) * 4 + Math.sin(py * 0.03) * 6;

      for (let px = 0; px < W; px++) {
        const gx = (px / CELL) | 0;
        const gxFrac = (px / CELL) - gx;
        const i = (py * W + px) * 4;
        const v = cellAt(gx, gy);

        if (v > 0) {
          // ── Bilinear edge detection ──
          // Sample 4 neighboring cells for smooth edges
          const vR = cellAt(gx + 1, gy);
          const vB = cellAt(gx, gy + 1);
          const vRB = cellAt(gx + 1, gy + 1);
          const nearTunnel = (!vR || !vB || !vRB ||
            !cellAt(gx - 1, gy) || !cellAt(gx, gy - 1) ||
            !cellAt(gx - 1, gy - 1) || !cellAt(gx + 1, gy - 1) || !cellAt(gx - 1, gy + 1));

          // Base sand color with depth darkening
          const darkening = 1 - depthFactor * 0.3;
          let r = (SAND_R + strataShift) * darkening;
          let g = (SAND_G + strataShift * 0.6) * darkening;
          let b = (SAND_B + strataShift * 0.3) * darkening;

          // Pixel noise for texture
          const noise = (pixelHash(px, py) - 0.5) * 16;
          r += noise; g += noise * 0.8; b += noise * 0.6;

          // Edge shadow (bilinear smooth)
          if (nearTunnel) {
            // Count empty neighbors with distance weighting
            let shadow = 0, samples = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                samples++;
                if (!isSolid(gx + dx, gy + dy)) {
                  const w = (dx === 0 || dy === 0) ? 1.0 : 0.7; // Cardinal neighbors weighted more
                  shadow += w;
                }
              }
            }
            const shadowFactor = shadow / (samples * 0.8);
            const edgeDarken = shadowFactor * 0.35;
            r *= (1 - edgeDarken);
            g *= (1 - edgeDarken);
            b *= (1 - edgeDarken);
          }

          // Cell hardness tint — harder cells slightly more reddish
          if (v >= 3) {
            r += (v - 2) * 3;
            g -= (v - 2) * 1;
          }

          d[i] = Math.max(0, Math.min(255, r)) | 0;
          d[i + 1] = Math.max(0, Math.min(255, g)) | 0;
          d[i + 2] = Math.max(0, Math.min(255, b)) | 0;
          d[i + 3] = 255;
        } else {
          // Tunnel/air — dark underground
          const tunnelDepth = depthFactor * 0.15;
          d[i] = (10 + tunnelDepth * 8) | 0;
          d[i + 1] = (8 + tunnelDepth * 6) | 0;
          d[i + 2] = (6 + tunnelDepth * 4) | 0;
          d[i + 3] = 255;
        }
      }
    }

    tCtx.putImageData(tImg, 0, 0);
    terrainImageData = tCtx.getImageData(0, 0, W, H);
    terrainDirty = false;
  }

  // Reduced blur — the pixel-level rendering already handles edges
  ctx.filter = 'blur(0.5px)';
  ctx.drawImage(tOff, 0, 0);
  ctx.filter = 'none';
  ctx.globalAlpha = 0.4;
  ctx.drawImage(tOff, 0, 0);
  ctx.globalAlpha = 1.0;
}

function renderFrame() {
  const green = '#2d8c3c', greenDark = '#1e6b2b', greenLight = '#3aad4d';
  ctx.fillStyle = green;
  ctx.fillRect(0, 0, W, FRAME); ctx.fillRect(0, H - FRAME * 2.5, W, FRAME * 2.5);
  ctx.fillRect(0, 0, FRAME, H); ctx.fillRect(W - FRAME, 0, FRAME, H);

  const boltR = 5;
  for (const [bx, by] of [[FRAME / 2, FRAME / 2], [W - FRAME / 2, FRAME / 2], [FRAME / 2, H - FRAME * 1.5], [W - FRAME / 2, H - FRAME * 1.5], [FRAME / 2, H * 0.35], [W - FRAME / 2, H * 0.35], [FRAME / 2, H * 0.65], [W - FRAME / 2, H * 0.65]]) {
    ctx.beginPath(); ctx.arc(bx, by, boltR, 0, 6.28); ctx.fillStyle = greenDark; ctx.fill();
    ctx.beginPath(); ctx.arc(bx - 1, by - 1, boltR * 0.6, 0, 6.28); ctx.fillStyle = greenLight; ctx.fill();
  }
  ctx.textAlign = 'center';
  for (let i = 0; i < 7; i++) { ctx.beginPath(); ctx.arc(W * 0.35 + i * 12, FRAME * 0.5, 2, 0, 6.28); ctx.fillStyle = greenDark; ctx.fill(); }
  ctx.strokeStyle = greenLight; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(FRAME, 1); ctx.lineTo(W - FRAME, 1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(1, FRAME); ctx.lineTo(1, H - FRAME * 2.5); ctx.stroke();
  ctx.strokeStyle = greenDark;
  ctx.beginPath(); ctx.moveTo(FRAME, FRAME - 1); ctx.lineTo(W - FRAME, FRAME - 1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W - 2, FRAME); ctx.lineTo(W - 2, H - FRAME * 2.5); ctx.stroke();
}

function renderSilhouette() {
  const y = SURFACE_PX, left = FRAME, right = W - FRAME;
  ctx.save(); ctx.fillStyle = '#2a8a38';

  // Ground line with gentle hills
  ctx.fillRect(left, y - 1, right - left, 3);
  ctx.beginPath(); ctx.moveTo(left, y);
  for (let x = left; x <= right; x++) {
    const hill = Math.sin((x - left) * 0.006) * 5 + Math.sin((x - left) * 0.018) * 2;
    ctx.lineTo(x, y - hill - 2);
  }
  ctx.lineTo(right, y); ctx.closePath(); ctx.fill();

  // Just a few trees — simple, sparse
  for (const tx of [left + 60, left + 280, right - 230, right - 80]) {
    ctx.fillRect(tx, y - 16, 2.5, 14);
    ctx.beginPath(); ctx.arc(tx + 1.2, y - 19, 7, 0, 6.28); ctx.fill();
  }

  // Simple grass tufts
  ctx.fillStyle = '#1e6b2b';
  for (let gx = left + 20; gx < right - 20; gx += 35 + Math.sin(gx * 0.1) * 15) {
    ctx.fillRect(gx, y - 4, 1.5, 4);
    ctx.fillRect(gx + 3, y - 5, 1.5, 5);
    ctx.fillRect(gx + 6, y - 3, 1.5, 3);
  }

  ctx.restore();
}

function renderFood() {
  for (const f of foods) {
    const amt = f.amount || 3;
    const baseR = 3 + amt * 0.6;
    // Scent glow
    ctx.beginPath(); ctx.arc(f.x, f.y, baseR * 2.5, 0, 6.28);
    ctx.fillStyle = 'rgba(180,140,60,0.04)'; ctx.fill();

    // Draw as a cluster of crumbs/sugar (what ants actually eat)
    const seed = (f.x * 137 + f.y * 269) | 0;
    const crumbCount = Math.min(amt + 2, 8);
    for (let i = 0; i < crumbCount; i++) {
      const h = ((seed + i * 7919) * 2654435761) >>> 0;
      const cx = f.x + ((h & 0xFF) / 255 - 0.5) * baseR * 2;
      const cy = f.y + (((h >> 8) & 0xFF) / 255 - 0.5) * baseR * 1.5;
      const cr = 1 + ((h >> 16) & 0x3) * 0.5;
      const kind = (h >> 20) & 0x3; // 0=sugar, 1=crumb, 2=fruit, 3=seed
      if (kind === 0) {
        // Sugar crystal — white/off-white cube
        ctx.fillStyle = 'rgba(245,240,230,0.9)';
        ctx.fillRect(cx - cr, cy - cr, cr * 2, cr * 1.8);
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.fillRect(cx - cr + 0.5, cy - cr + 0.5, cr, cr * 0.6);
      } else if (kind === 1) {
        // Bread crumb — warm brown
        ctx.fillStyle = 'rgba(180,140,80,0.85)';
        ctx.beginPath(); ctx.arc(cx, cy, cr, 0, 6.28); ctx.fill();
        ctx.fillStyle = 'rgba(200,165,100,0.4)';
        ctx.beginPath(); ctx.arc(cx - 0.3, cy - 0.3, cr * 0.5, 0, 6.28); ctx.fill();
      } else if (kind === 2) {
        // Fruit bit — reddish/orange
        ctx.fillStyle = 'rgba(200,80,40,0.85)';
        ctx.beginPath(); ctx.arc(cx, cy, cr * 1.1, 0, 6.28); ctx.fill();
        ctx.fillStyle = 'rgba(230,120,60,0.3)';
        ctx.beginPath(); ctx.arc(cx - 0.3, cy - 0.4, cr * 0.5, 0, 6.28); ctx.fill();
      } else {
        // Seed — dark oval
        ctx.fillStyle = 'rgba(90,60,30,0.8)';
        ctx.beginPath(); ctx.ellipse(cx, cy, cr * 1.2, cr * 0.6, (h & 0xF) * 0.4, 0, 6.28); ctx.fill();
      }
    }
  }
}

function renderParticles() {
  // Regular particles (hauling trail, etc.)
  for (const p of particles) {
    const a = Math.max(0, p.life / 35);
    ctx.fillStyle = `rgba(${p.r | 0},${p.g | 0},${p.b | 0},${a.toFixed(2)})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, 6.28); ctx.fill();
  }
  // Terrain diff particles (dug / deposited sand)
  for (const p of terrainParticles) {
    const a = Math.max(0, p.life / 50);
    ctx.fillStyle = `rgba(${p.r | 0},${p.g | 0},${p.b | 0},${a.toFixed(2)})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, 6.28); ctx.fill();
  }
}

// ═══════════════════════════════════════════════════════════════════
//  ANT RENDERING — Side-view with state-dependent posture
// ═══════════════════════════════════════════════════════════════════

function renderAnt3D(ant) {
  const x = ant.x, y = ant.y + (ant.bodyBob || 0), s = ant.size;
  const facingRight = ant.vx >= 0 ? 1 : -1;
  const mov = Math.hypot(ant.vx, ant.vy) > 0.08 && !ant.isPaused;
  const posture = getAntPosture(ant);

  ctx.save();
  ctx.translate(x, y);
  ctx.scale(facingRight, 1);

  // Apply body tilt from posture
  if (posture.bodyTilt) ctx.rotate(posture.bodyTilt);

  // Bold black silhouette style — like the reference icon
  const col = '#1a1a1a';

  // === LEGS (3 pairs — thick, angular, geometric) ===
  ctx.strokeStyle = col;
  ctx.lineWidth = s * 0.22; ctx.lineCap = 'round'; ctx.lineJoin = 'round';

  for (let i = 0; i < 3; i++) {
    const tripodOffset = (i === 1) ? Math.PI : 0;
    const phase = (mov || posture.legSpeed > 0) ? Math.sin(ant.legT + tripodOffset) * posture.legSpeed : 0;
    const attachX = -s * 0.3 + i * s * 0.65;
    const attachY = s * 0.1;
    // Knee goes up then down — angular like reference
    const kneeX = attachX + phase * s * 0.2;
    const kneeY = attachY + s * 0.55;
    const footX = kneeX + (i - 1) * s * 0.15 + phase * s * 0.3;
    const footY = attachY + s * 1.1 + Math.abs(phase) * s * 0.1;

    ctx.beginPath();
    ctx.moveTo(attachX, attachY);
    ctx.lineTo(kneeX, kneeY);
    ctx.lineTo(footX, footY);
    ctx.stroke();
    // Foot — small flat end
    ctx.beginPath();
    ctx.moveTo(footX - s * 0.1, footY);
    ctx.lineTo(footX + s * 0.15, footY + s * 0.04);
    ctx.stroke();
  }

  // === ABDOMEN (large oval, solid black) ===
  const abdX = -s * 0.9, abdY = -s * 0.05;
  const abdPulse = posture.abdomenPulse || 1.0;
  ctx.fillStyle = col;
  ctx.beginPath();
  ctx.ellipse(abdX, abdY, s * 0.95, s * 0.6 * abdPulse, -0.1, 0, 6.28);
  ctx.fill();

  // === PETIOLE (narrow waist) ===
  ctx.beginPath();
  ctx.ellipse(-s * 0.05, 0, s * 0.13, s * 0.1, 0, 0, 6.28);
  ctx.fill();

  // === THORAX (smaller oval) ===
  const thX = s * 0.3, thY = -s * 0.03;
  ctx.beginPath();
  ctx.ellipse(thX, thY, s * 0.4, s * 0.3, -0.15, 0, 6.28);
  ctx.fill();

  // === HEAD (round, slightly pointed forward) ===
  const headDip = posture.headDip || 0;
  const hdX = s * 0.85, hdY = s * 0.02 + headDip * s;
  ctx.beginPath();
  ctx.ellipse(hdX, hdY, s * 0.35, s * 0.3, 0.1, 0, 6.28);
  ctx.fill();

  // Eye (small white dot)
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(hdX + s * 0.14, hdY - s * 0.06, s * 0.06, 0, 6.28);
  ctx.fill();

  // === MANDIBLES (bold, angular — key feature of reference) ===
  ctx.strokeStyle = col; ctx.lineWidth = s * 0.18; ctx.lineCap = 'round';
  const mO = posture.mandibleOpen + (mov ? Math.sin(ant.legT * 0.5) * 0.04 : 0);
  // Top mandible
  ctx.beginPath();
  ctx.moveTo(hdX + s * 0.25, hdY - s * 0.08);
  ctx.lineTo(hdX + s * 0.6, hdY - s * 0.2 - mO * s * 0.8);
  ctx.stroke();
  // Bottom mandible
  ctx.beginPath();
  ctx.moveTo(hdX + s * 0.25, hdY + s * 0.08);
  ctx.lineTo(hdX + s * 0.6, hdY + s * 0.2 + mO * s * 0.8);
  ctx.stroke();

  // === Sand grain in mandibles ===
  if (ant.carryingSand > 0) {
    const grainSize = s * (0.18 + ant.carryingSand * 0.04);
    ctx.fillStyle = `rgb(${SAND_R},${SAND_G},${SAND_B})`;
    ctx.beginPath(); ctx.arc(hdX + s * 0.5, hdY, grainSize, 0, 6.28); ctx.fill();
  }

  // === ANTENNA (bold, angled — one visible in side view) ===
  ctx.strokeStyle = col; ctx.lineWidth = s * 0.12;
  const antBob = Math.sin(ant.antT) * 0.12;
  ctx.beginPath();
  ctx.moveTo(hdX + s * 0.15, hdY - s * 0.2);
  ctx.quadraticCurveTo(hdX + s * 0.35, hdY - s * 0.65 + antBob * s,
    hdX + s * 0.65, hdY - s * 0.75 + antBob * s);
  ctx.stroke();
  // Antenna tip ball
  ctx.fillStyle = col;
  ctx.beginPath();
  ctx.arc(hdX + s * 0.65, hdY - s * 0.75 + antBob * s, s * 0.06, 0, 6.28);
  ctx.fill();

  // Carrying food
  if (ant.carrying) {
    ctx.fillStyle = '#78b840';
    ctx.beginPath(); ctx.arc(hdX + s * 0.45, hdY - s * 0.05, s * 0.25, 0, 6.28); ctx.fill();
  }

  // Queen marker (subtle golden crown dot)
  if (ant.isQueen) {
    ctx.fillStyle = 'rgba(255,200,50,0.6)';
    ctx.beginPath(); ctx.arc(thX, thY - s * 0.5, s * 0.15, 0, 6.28); ctx.fill();
  }

  // Hover highlight
  if (hoveredAnt === ant) {
    ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.ellipse(0, 0, s * 2.2, s * 1.5, 0, 0, 6.28); ctx.stroke();
  }

  // Digging dust particles
  if (posture.dustChance > 0 && Math.random() < posture.dustChance && mov) {
    particles.push({
      x: ant.x + (facingRight * s * 1.5),
      y: ant.y + s * 0.3,
      vx: (Math.random() - 0.5) * 1.5 * facingRight,
      vy: Math.random() * -1.2 - 0.3,
      life: 15 + Math.random() * 10,
      size: 0.8 + Math.random() * 0.8,
      r: SAND_R - 5, g: SAND_G - 5, b: SAND_B - 3
    });
  }

  ctx.restore();
}

function renderTandemLines() {
  ctx.strokeStyle = 'rgba(255,200,100,0.15)';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 4]);
  for (const ant of ants) {
    if (ant.tandemTargetId) {
      const target = ants.find(a => a.id === ant.tandemTargetId);
      if (target) {
        ctx.beginPath();
        ctx.moveTo(ant.x, ant.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
      }
    }
  }
  ctx.setLineDash([]);
}

function renderGlass() {
  const g = ctx.createLinearGradient(0, 0, W * 0.6, H * 0.4);
  g.addColorStop(0, 'rgba(255,255,255,0.04)'); g.addColorStop(0.4, 'rgba(255,255,255,0)');
  g.addColorStop(0.8, 'rgba(255,255,255,0.02)'); g.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = g; ctx.fillRect(FRAME, FRAME, W - FRAME * 2, H - FRAME * 3.5);
  ctx.save(); ctx.globalAlpha = 0.025; ctx.translate(W * 0.25, 0); ctx.rotate(0.25);
  ctx.fillStyle = '#fff'; ctx.fillRect(-15, 0, 30, H * 1.5); ctx.restore();
}

function renderFallingObjects() {
  for (const f of fallingObjects) {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.rotate(f.rotation);
    if (f.type === 'ant') {
      // Simple falling ant silhouette
      const s = 3.5;
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath(); ctx.ellipse(-s * 0.9, 0, s * 0.9, s * 0.55, 0, 0, 6.28); ctx.fill(); // abdomen
      ctx.beginPath(); ctx.ellipse(0, 0, s * 0.12, s * 0.1, 0, 0, 6.28); ctx.fill(); // petiole
      ctx.beginPath(); ctx.ellipse(s * 0.3, 0, s * 0.35, s * 0.28, 0, 0, 6.28); ctx.fill(); // thorax
      ctx.beginPath(); ctx.ellipse(s * 0.75, 0, s * 0.3, s * 0.25, 0, 0, 6.28); ctx.fill(); // head
      // Legs splayed out (falling pose)
      ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = s * 0.18;
      for (let i = 0; i < 3; i++) {
        const lx = -s * 0.3 + i * s * 0.5;
        ctx.beginPath(); ctx.moveTo(lx, 0); ctx.lineTo(lx - s * 0.4, s * 0.8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(lx, 0); ctx.lineTo(lx + s * 0.3, -s * 0.7); ctx.stroke();
      }
    } else if (f.type === 'food') {
      // Falling food crumb
      ctx.fillStyle = f.color || '#b48c50';
      ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, 6.28); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath(); ctx.arc(-0.5, -0.5, 1, 0, 6.28); ctx.fill();
    }
    ctx.restore();
  }
}

let renderFrame_counter = 0;

function render() {
  if (!grid) return;
  ctx.clearRect(0, 0, W, H);
  renderTerrain();
  renderSilhouette();
  renderFood();
  renderParticles();
  renderTandemLines();
  for (const ant of ants) renderAnt3D(ant);
  renderFallingObjects();
  renderFrame();
  renderGlass();
}

// ═══════════════════════════════════════════════════════════════════
//  TOOLTIP
// ═══════════════════════════════════════════════════════════════════

function updateTooltip() {
  if (!running) return;
  const rect = canvas.getBoundingClientRect();
  const sx = W / rect.width, sy = H / rect.height;
  const cx = (mouseX - rect.left) * sx, cy = (mouseY - rect.top) * sy;
  hoveredAnt = null; let closest = 15;
  for (const ant of ants) {
    const d = Math.hypot(ant.x - cx, ant.y - cy);
    if (d < closest) { closest = d; hoveredAnt = ant; }
  }
  if (hoveredAnt) {
    const a = hoveredAnt;
    document.getElementById('ttName').textContent = a.name;
    document.getElementById('ttState').textContent = (ST_NAMES[a.state] || 'Unknown') + (a.isPaused ? ' (paused)' : '');
    document.getElementById('ttEnergy').textContent = Math.round(a.energy);
    document.getElementById('ttRole').textContent = a.role + (a.isQueen ? ' (queen)' : '') + (a.carryingSand > 0 ? ' [hauling]' : '');
    document.getElementById('ttThought').textContent = a.lastThought || '—';
    tooltip.classList.add('show');
    tooltip.style.left = (mouseX + 16) + 'px'; tooltip.style.top = (mouseY - 12) + 'px';
  } else tooltip.classList.remove('show');
}
document.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; updateTooltip(); });

// ═══════════════════════════════════════════════════════════════════
//  ADMIN PANEL — Hidden, triggered by j+k+l
// ═══════════════════════════════════════════════════════════════════

const keysDown = new Set();
let adminVisible = false;

document.addEventListener('keydown', e => {
  keysDown.add(e.key.toLowerCase());
  if (keysDown.has('j') && keysDown.has('k') && keysDown.has('l')) {
    adminVisible = !adminVisible;
    document.getElementById('adminPanel').classList.toggle('show', adminVisible);
    keysDown.clear();
  }
});
document.addEventListener('keyup', e => {
  keysDown.delete(e.key.toLowerCase());
});

async function adminAction(action, value) {
  // Immediate visual feedback — spawn falling objects on client
  if (action === 'addAnts') {
    for (let i = 0; i < 5; i++) {
      fallingObjects.push({
        type: 'ant',
        x: W * 0.3 + Math.random() * W * 0.4,
        y: FRAME + 5,
        vx: (Math.random() - 0.5) * 2,
        vy: Math.random() * 2,
        rotation: (Math.random() - 0.5) * 1.5,
        rotSpeed: (Math.random() - 0.5) * 0.15,
      });
    }
  } else if (action === 'dropFood') {
    const colors = ['#b48c50', '#e8d8b0', '#c85028', '#5a3c1e'];
    for (let i = 0; i < 6; i++) {
      fallingObjects.push({
        type: 'food',
        x: W * 0.35 + Math.random() * W * 0.3,
        y: FRAME + 5,
        vx: (Math.random() - 0.5) * 3,
        vy: Math.random() * 1.5,
        rotation: 0,
        rotSpeed: (Math.random() - 0.5) * 0.2,
        color: colors[(Math.random() * colors.length) | 0],
      });
    }
  }

  try {
    const res = await fetch('/api/admin', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action, value, secret: 'admin' })
    });
    const data = await res.json();
    if (data.ok) {
      toast(data.message || 'Done');
      if (action === 'setSpeed') {
        document.getElementById('speedVal').textContent = value + 'x';
      }
    } else {
      toast('Error: ' + (data.error || 'Unknown'));
    }
  } catch (err) {
    toast('Admin error');
  }
}

// ═══════════════════════════════════════════════════════════════════
//  RENDER LOOP
// ═══════════════════════════════════════════════════════════════════

function tick() {
  renderFrame_counter++;
  interpolateAnts();
  tickParticles();
  render();
  updateHUD();
  requestAnimationFrame(tick);
}

// ═══════════════════════════════════════════════════════════════════
//  HUD
// ═══════════════════════════════════════════════════════════════════

function updateHUD() {
  const pct = grid ? (totalDug / ((ROWS - SURFACE) * COLS) * 100).toFixed(1) : '0.0';
  document.getElementById('sAnts').textContent = ants.length;
  document.getElementById('sTunnel').textContent = pct + '%';
  document.getElementById('sChambers').textContent = chambers.length;
  document.getElementById('sDay').textContent = simDay;
}

function toast(msg) {
  const el = document.getElementById('toast'); el.textContent = msg; el.classList.add('show');
  clearTimeout(el._t); el._t = setTimeout(() => el.classList.remove('show'), 1800);
}

// ═══════════════════════════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════════════════════════

async function begin() {
  document.getElementById('intro').classList.add('hide');
  setTimeout(async () => {
    document.getElementById('intro').style.display = 'none';
    document.getElementById('app').classList.add('show');
    canvas.width = W; canvas.height = H; resizeCanvas();

    running = true;
    await fetchState();
    tick();
    setInterval(fetchState, POLL_INTERVAL);
    toast('Connected to live colony');
  }, 500);
}

function resizeCanvas() {
  const wrap = document.getElementById('wrap');
  const ww = wrap.clientWidth, wh = wrap.clientHeight;
  const aspect = W / H, wrapAspect = ww / wh;
  let cw, ch;
  if (wrapAspect > aspect) { ch = wh; cw = wh * aspect; } else { cw = ww; ch = ww / aspect; }
  canvas.style.width = cw + 'px'; canvas.style.height = ch + 'px';
}
window.addEventListener('resize', () => { if (running) resizeCanvas(); });
</script>
</body>
</html>
