<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Antfarm</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;1,400&family=Inter:wght@300;400;500&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #fff; color: #1a1a1a;
    font-family: 'Inter', -apple-system, sans-serif;
    height: 100vh; overflow: hidden; -webkit-font-smoothing: antialiased;
  }
  .intro {
    position: fixed; inset: 0; background: #fff;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 100; transition: opacity 0.8s ease;
  }
  .intro.hide { opacity: 0; pointer-events: none; }
  .intro h1 { font-family: 'EB Garamond', serif; font-size: clamp(2.5rem, 5vw, 4.5rem); font-weight: 400; margin-bottom: 12px; }
  .intro h1 em { font-style: italic; }
  .intro .sub { color: #999; font-size: 0.82rem; letter-spacing: 0.08em; margin-bottom: 12px; }
  .intro .sub2 { color: #bbb; font-size: 0.7rem; letter-spacing: 0.06em; margin-bottom: 48px; }
  .intro button {
    background: none; border: 1px solid #ddd; color: #1a1a1a;
    font-family: 'Inter', sans-serif; font-size: 0.78rem; letter-spacing: 0.14em;
    text-transform: uppercase; padding: 14px 44px; cursor: pointer; transition: all 0.3s;
  }
  .intro button:hover { border-color: #1a1a1a; background: #1a1a1a; color: #fff; }
  .app { display: none; height: 100vh; flex-direction: column; }
  .app.show { display: flex; }
  .topbar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 24px; height: 48px; flex-shrink: 0; border-bottom: 1px solid #eee;
  }
  .topbar .title { font-family: 'EB Garamond', serif; font-size: 1.15rem; font-weight: 400; }
  .topbar .title em { font-style: italic; }
  .topbar .stats { display: flex; gap: 24px; font-size: 0.72rem; color: #999; letter-spacing: 0.04em; }
  .topbar .stats .v { color: #1a1a1a; font-weight: 500; margin-left: 6px; font-variant-numeric: tabular-nums; }
  .canvas-wrap {
    flex: 1; position: relative; overflow: hidden;
    background: #e8e0d4; cursor: crosshair;
    display: flex; align-items: center; justify-content: center;
  }
  .canvas-wrap canvas { display: block; }
  .ant-tooltip {
    position: fixed; pointer-events: none;
    background: rgba(255,255,255,0.95); backdrop-filter: blur(8px);
    border: 1px solid #e0e0e0; padding: 8px 12px;
    font-size: 0.68rem; line-height: 1.5; color: #555;
    z-index: 50; opacity: 0; transition: opacity 0.15s ease; max-width: 220px; white-space: nowrap;
  }
  .ant-tooltip.show { opacity: 1; }
  .ant-tooltip .tt-name { color: #1a1a1a; font-weight: 500; margin-bottom: 2px; font-size: 0.72rem; }
  .ant-tooltip .tt-row { display: flex; justify-content: space-between; gap: 12px; }
  .ant-tooltip .tt-val { color: #1a1a1a; font-weight: 500; }
  .bottombar {
    display: flex; align-items: center; justify-content: center; gap: 1px;
    height: 40px; flex-shrink: 0; border-top: 1px solid #eee; background: #fff;
  }
  .bottombar .status {
    font-size: 0.68rem; color: #aaa; letter-spacing: 0.04em;
    padding: 0 20px; display: flex; align-items: center; gap: 8px;
  }
  .bottombar .status .dot {
    width: 6px; height: 6px; border-radius: 50%; background: #4ade80;
    animation: pulse 2s infinite;
  }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
  .toast {
    position: fixed; bottom: 56px; left: 50%; transform: translateX(-50%) translateY(8px);
    background: #1a1a1a; color: #fff; padding: 8px 20px; font-size: 0.72rem;
    opacity: 0; transition: all 0.25s ease; z-index: 90; pointer-events: none;
  }
  .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
  .ai-thought {
    position: fixed; bottom: 56px; right: 24px;
    background: rgba(255,255,255,0.95); backdrop-filter: blur(8px);
    border: 1px solid #e0e0e0; padding: 10px 16px;
    font-size: 0.72rem; line-height: 1.5; color: #555;
    z-index: 90; opacity: 0; transition: all 0.6s ease; max-width: 320px;
    pointer-events: none;
  }
  .ai-thought.show { opacity: 1; }
  .ai-thought .ai-label { color: #aaa; font-size: 0.6rem; letter-spacing: 0.08em; text-transform: uppercase; margin-bottom: 4px; }
  .ai-thought .ai-text { color: #444; font-family: 'EB Garamond', serif; font-size: 0.85rem; font-style: italic; line-height: 1.5; }
</style>
</head>
<body>

<div class="intro" id="intro">
  <h1><em>Antfarm</em></h1>
  <p class="sub">a living colony simulation</p>
  <p class="sub2">guided by Claude AI — shared with everyone</p>
  <button onclick="begin()">Enter</button>
</div>

<div class="app" id="app">
  <div class="topbar">
    <div class="title"><em>Antfarm</em></div>
    <div class="stats">
      <span>Population<span class="v" id="sAnts">0</span></span>
      <span>Tunneled<span class="v" id="sTunnel">0%</span></span>
      <span>Chambers<span class="v" id="sChambers">0</span></span>
      <span>Day<span class="v" id="sDay">1</span></span>
    </div>
  </div>
  <div class="canvas-wrap" id="wrap">
    <canvas id="c"></canvas>
  </div>
  <div class="bottombar">
    <div class="status">
      <span class="dot"></span>
      <span id="statusText">Connecting to colony...</span>
    </div>
  </div>
</div>

<div class="ant-tooltip" id="tooltip">
  <div class="tt-name" id="ttName"></div>
  <div class="tt-row"><span>State</span><span class="tt-val" id="ttState"></span></div>
  <div class="tt-row"><span>Energy</span><span class="tt-val" id="ttEnergy"></span></div>
  <div class="tt-row"><span>Age</span><span class="tt-val" id="ttAge"></span></div>
  <div class="tt-row"><span>Role</span><span class="tt-val" id="ttRole"></span></div>
  <div class="tt-row"><span>Thought</span><span class="tt-val" id="ttThought"></span></div>
</div>
<div class="toast" id="toast"></div>
<div class="ai-thought" id="aiThought">
  <div class="ai-label">Colony Intelligence</div>
  <div class="ai-text" id="aiText"></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════
//  ANTFARM — Viewer Client
//  Fetches colony state from /api/state every 3 seconds
//  Renders ants + terrain with smooth interpolation
//  All simulation runs server-side — this is purely a renderer
// ═══════════════════════════════════════════════════════════════════

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

// ── Constants (must match server) ──
const W = 960, H = 680;
const CELL = 3;
const COLS = W / CELL, ROWS = Math.ceil(H / CELL);
const SURFACE = Math.round(ROWS * 0.27);
const SURFACE_PX = SURFACE * CELL;
const FRAME = 14;
const SAND_R = 212, SAND_G = 194, SAND_B = 162;

// ── State Names ──
const ST_NAMES = [
  'Wandering', 'Entering', 'Digging down', 'Branching', 'Carving chamber',
  'Exploring', 'Returning', 'Foraging', 'Carrying food', 'Resting', 'Wall following',
  'Hauling sand', 'Leading', 'Following', 'Communicating', 'Pausing', 'Navigating to dig site'
];

// ── Viewer State ──
let grid = null;          // Uint8Array from server
let ants = [];            // Current ant positions (interpolated)
let antsTarget = [];      // Target ant positions (from latest server state)
let antsPrev = [];        // Previous ant positions (for interpolation)
let foods = [];
let chambers = [];
let particles = [];
let frame = 0, totalDug = 0, simDay = 1;
let running = false;
let hoveredAnt = null, mouseX = 0, mouseY = 0;
let terrainDirty = true;
let lastNarration = '';
let narrationTimeout = null;
let lastFetchTime = 0;
let interpolateT = 0;     // 0-1, how far between prev and target state
const POLL_INTERVAL = 3000; // Fetch every 3 seconds
const INTERP_SPEED = 1.0 / (POLL_INTERVAL / 16.67); // reach target in one poll interval

// ── Offscreen terrain canvas ──
const tOff = document.createElement('canvas');
tOff.width = W; tOff.height = H;
const tCtx = tOff.getContext('2d');
let terrainImageData;

// ═══════════════════════════════════════════════════════════════════
//  BASE64 DECODE — match server encoding
// ═══════════════════════════════════════════════════════════════════

function base64ToUint8(b64) {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return arr;
}

// ═══════════════════════════════════════════════════════════════════
//  SERVER STATE FETCHING
// ═══════════════════════════════════════════════════════════════════

async function fetchState() {
  try {
    const res = await fetch('/api/state');
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();

    if (data.status === 'initializing') {
      document.getElementById('statusText').textContent = 'Colony initializing...';
      return;
    }

    // Decode grid from base64
    if (data.grid && typeof data.grid === 'string') {
      grid = base64ToUint8(data.grid);
      terrainDirty = true;
    }

    // Update state
    totalDug = data.totalDug || 0;
    simDay = data.simDay || 1;
    frame = data.frame || 0;
    foods = data.foods || [];
    chambers = data.chambers || [];

    // Save previous ant positions for interpolation
    antsPrev = ants.map(a => ({ ...a }));

    // Update target ant positions
    antsTarget = (data.ants || []).map(a => ({
      id: a.id,
      x: a.x, y: a.y,
      vx: a.vx, vy: a.vy,
      state: a.state,
      role: a.role,
      isQueen: a.isQueen,
      carrying: a.carrying,
      carryingSand: a.carryingSand,
      size: a.size,
      hue: a.hue,
      legT: a.legT,
      antT: a.antT,
      bodyBob: a.bodyBob,
      isPaused: a.isPaused,
      antennateTimer: a.antennateTimer,
      name: a.name,
      energy: a.energy,
      age: a.age || 0,
      lastThought: a.lastThought || '',
      tandemTargetId: a.tandemTargetId
    }));

    // Match previous ants to new ants by ID for smooth interpolation
    if (antsPrev.length === 0) {
      // First load — no interpolation needed
      ants = antsTarget.map(a => ({ ...a }));
    } else {
      // Map old ants by ID
      const prevMap = {};
      for (const a of antsPrev) prevMap[a.id] = a;

      ants = antsTarget.map(a => {
        const prev = prevMap[a.id];
        if (prev) {
          // Keep previous position, will interpolate to target
          return { ...a, x: prev.x, y: prev.y, legT: prev.legT, antT: prev.antT, bodyBob: prev.bodyBob };
        }
        return { ...a }; // New ant, no interpolation
      });
    }
    interpolateT = 0;

    // Show narration from Claude
    if (data.narration && data.narration !== lastNarration) {
      lastNarration = data.narration;
      showNarration(data.narration);
    }

    // Update status
    document.getElementById('statusText').textContent = 'Live colony — Day ' + simDay;
    lastFetchTime = Date.now();

  } catch (err) {
    console.error('Fetch error:', err);
    document.getElementById('statusText').textContent = 'Reconnecting...';
  }
}

function showNarration(text) {
  const el = document.getElementById('aiThought');
  document.getElementById('aiText').textContent = text;
  el.classList.add('show');
  clearTimeout(narrationTimeout);
  narrationTimeout = setTimeout(() => el.classList.remove('show'), 12000);
}

// ═══════════════════════════════════════════════════════════════════
//  INTERPOLATION — Smooth ant movement between server snapshots
// ═══════════════════════════════════════════════════════════════════

function interpolateAnts() {
  interpolateT = Math.min(1, interpolateT + INTERP_SPEED);
  const t = interpolateT;

  for (let i = 0; i < ants.length; i++) {
    const ant = ants[i];
    const target = antsTarget.find(a => a.id === ant.id);
    if (!target) continue;

    // Smooth position interpolation
    ant.x += (target.x - ant.x) * 0.08;
    ant.y += (target.y - ant.y) * 0.08;

    // Copy non-position state directly
    ant.state = target.state;
    ant.role = target.role;
    ant.carrying = target.carrying;
    ant.carryingSand = target.carryingSand;
    ant.isPaused = target.isPaused;
    ant.antennateTimer = target.antennateTimer;
    ant.lastThought = target.lastThought;
    ant.energy = target.energy;

    // Animate legs/antenna continuously for visual fidelity
    const moving = Math.hypot(target.vx, target.vy) > 0.08;
    if (moving) {
      ant.legT += 0.35;
      ant.antT += 0.08;
      ant.bodyBob = Math.sin(ant.legT * 0.4) * 0.3;
    }
    ant.vx = target.vx;
    ant.vy = target.vy;
  }
}

// ═══════════════════════════════════════════════════════════════════
//  TERRAIN HELPERS
// ═══════════════════════════════════════════════════════════════════

function cellAt(x, y) {
  return (x < 0 || x >= COLS || y < 0 || y >= ROWS) ? 255 : grid[y * COLS + x];
}

function isSolid(x, y) { return cellAt(x, y) > 0; }

function airFraction(gx, gy) {
  let air = 0, total = 0;
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      total++;
      if (!isSolid(gx + dx, gy + dy)) air++;
    }
  }
  return air / total;
}

// ═══════════════════════════════════════════════════════════════════
//  PARTICLES — Visual-only decorative particles
// ═══════════════════════════════════════════════════════════════════

function tickParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.vx *= 0.97;
    if (--p.life <= 0) particles.splice(i, 1);
  }
}

// ═══════════════════════════════════════════════════════════════════
//  RENDERING — Smooth sand with SDF edges
// ═══════════════════════════════════════════════════════════════════

function renderTerrain() {
  if (!grid) return;

  if (!terrainDirty && terrainImageData) {
    tCtx.putImageData(terrainImageData, 0, 0);
  } else {
    const tImg = tCtx.createImageData(W, H);
    const d = tImg.data;

    // Sky
    for (let y = 0; y < SURFACE_PX; y++) {
      for (let x = 0; x < W; x++) {
        const i = (y * W + x) * 4;
        d[i] = 238; d[i + 1] = 235; d[i + 2] = 228; d[i + 3] = 255;
      }
    }

    // Ground
    for (let py = SURFACE_PX; py < H; py++) {
      const gy = (py / CELL) | 0;
      for (let px = 0; px < W; px++) {
        const gx = (px / CELL) | 0;
        const i = (py * W + px) * 4;
        const v = cellAt(gx, gy);

        if (v > 0) {
          let r = SAND_R, g = SAND_G, b = SAND_B;
          const af = airFraction(gx, gy);
          if (af > 0 && af < 1) {
            const shadow = af * 0.3;
            r *= (1 - shadow); g *= (1 - shadow); b *= (1 - shadow);
          }
          d[i] = r | 0; d[i + 1] = g | 0; d[i + 2] = b | 0; d[i + 3] = 255;
        } else {
          d[i] = 10; d[i + 1] = 8; d[i + 2] = 6; d[i + 3] = 255;
        }
      }
    }

    tCtx.putImageData(tImg, 0, 0);
    terrainImageData = tCtx.getImageData(0, 0, W, H);
    terrainDirty = false;
  }

  ctx.filter = 'blur(2.5px)';
  ctx.drawImage(tOff, 0, 0);
  ctx.filter = 'none';
  ctx.globalAlpha = 0.25;
  ctx.drawImage(tOff, 0, 0);
  ctx.globalAlpha = 1.0;
}

function renderFrame() {
  const green = '#2d8c3c', greenDark = '#1e6b2b', greenLight = '#3aad4d';
  ctx.fillStyle = green;
  ctx.fillRect(0, 0, W, FRAME); ctx.fillRect(0, H - FRAME * 2.5, W, FRAME * 2.5);
  ctx.fillRect(0, 0, FRAME, H); ctx.fillRect(W - FRAME, 0, FRAME, H);

  const boltR = 5;
  for (const [bx, by] of [[FRAME / 2, FRAME / 2], [W - FRAME / 2, FRAME / 2], [FRAME / 2, H - FRAME * 1.5], [W - FRAME / 2, H - FRAME * 1.5], [FRAME / 2, H * 0.35], [W - FRAME / 2, H * 0.35], [FRAME / 2, H * 0.65], [W - FRAME / 2, H * 0.65]]) {
    ctx.beginPath(); ctx.arc(bx, by, boltR, 0, 6.28); ctx.fillStyle = greenDark; ctx.fill();
    ctx.beginPath(); ctx.arc(bx - 1, by - 1, boltR * 0.6, 0, 6.28); ctx.fillStyle = greenLight; ctx.fill();
  }
  ctx.textAlign = 'center';
  for (let i = 0; i < 7; i++) { ctx.beginPath(); ctx.arc(W * 0.35 + i * 12, FRAME * 0.5, 2, 0, 6.28); ctx.fillStyle = greenDark; ctx.fill(); }
  ctx.strokeStyle = greenLight; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(FRAME, 1); ctx.lineTo(W - FRAME, 1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(1, FRAME); ctx.lineTo(1, H - FRAME * 2.5); ctx.stroke();
  ctx.strokeStyle = greenDark;
  ctx.beginPath(); ctx.moveTo(FRAME, FRAME - 1); ctx.lineTo(W - FRAME, FRAME - 1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W - 2, FRAME); ctx.lineTo(W - 2, H - FRAME * 2.5); ctx.stroke();
}

function renderSilhouette() {
  const y = SURFACE_PX, left = FRAME, right = W - FRAME;
  ctx.save(); ctx.fillStyle = '#2a8a38';
  ctx.fillRect(left, y - 2, right - left, 4);
  ctx.beginPath(); ctx.moveTo(left, y);
  for (let x = left; x <= right; x++) {
    const hill = Math.sin((x - left) * 0.008) * 6 + Math.sin((x - left) * 0.02) * 3;
    ctx.lineTo(x, y - hill - 2);
  }
  ctx.lineTo(right, y); ctx.closePath(); ctx.fill();

  // Barn
  let bx = left + 80;
  ctx.fillRect(bx, y - 30, 35, 28);
  ctx.beginPath(); ctx.moveTo(bx - 3, y - 30); ctx.lineTo(bx + 17, y - 46); ctx.lineTo(bx + 38, y - 30); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#1e6b2b'; ctx.fillRect(bx + 12, y - 16, 10, 14); ctx.fillStyle = '#2a8a38';

  // House
  bx = left + 160;
  ctx.fillRect(bx, y - 25, 28, 23);
  ctx.beginPath(); ctx.moveTo(bx - 2, y - 25); ctx.lineTo(bx + 14, y - 38); ctx.lineTo(bx + 30, y - 25); ctx.closePath(); ctx.fill();
  ctx.fillRect(bx + 22, y - 42, 5, 16);
  ctx.fillStyle = '#1e6b2b'; ctx.fillRect(bx + 8, y - 20, 6, 6); ctx.fillRect(bx + 17, y - 20, 6, 6); ctx.fillStyle = '#2a8a38';

  // Windmill
  const wmX = right - 200;
  ctx.fillRect(wmX, y - 40, 6, 38);
  ctx.save(); ctx.translate(wmX + 3, y - 40); ctx.rotate(renderFrame_counter * 0.008);
  for (let i = 0; i < 4; i++) { ctx.rotate(Math.PI / 2); ctx.fillRect(-2, 0, 4, 18); }
  ctx.restore();

  // Silo
  const sx = right - 120;
  ctx.fillRect(sx, y - 38, 16, 36);
  ctx.beginPath(); ctx.arc(sx + 8, y - 38, 8, Math.PI, 0); ctx.fill();
  ctx.beginPath(); ctx.moveTo(sx + 5, y - 44); ctx.lineTo(sx + 8, y - 52); ctx.lineTo(sx + 11, y - 44); ctx.closePath(); ctx.fill();

  // Big barn
  bx = right - 80;
  ctx.fillRect(bx, y - 32, 40, 30);
  ctx.beginPath(); ctx.moveTo(bx - 3, y - 32); ctx.lineTo(bx + 20, y - 48); ctx.lineTo(bx + 43, y - 32); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#1e6b2b'; ctx.beginPath(); ctx.arc(bx + 20, y - 36, 5, Math.PI, 0); ctx.fill(); ctx.fillStyle = '#2a8a38';

  // Trees
  for (const tx of [left + 30, left + 250, left + 350, right - 260, right - 160]) {
    ctx.fillRect(tx, y - 18, 3, 16); ctx.beginPath(); ctx.arc(tx + 1.5, y - 22, 9, 0, 6.28); ctx.fill();
  }
  // Fence
  for (let fx = left + 300; fx < left + 420; fx += 15) ctx.fillRect(fx, y - 10, 2, 8);
  ctx.fillRect(left + 300, y - 8, 120, 1.5); ctx.fillRect(left + 300, y - 5, 120, 1.5);
  ctx.restore();
}

function renderFood() {
  for (const f of foods) {
    const p = 1 + Math.sin(renderFrame_counter * 0.05) * 0.12, r = 3 + f.amount * 0.8;
    ctx.beginPath(); ctx.arc(f.x, f.y, r * 2 * p, 0, 6.28); ctx.fillStyle = 'rgba(70,170,50,0.06)'; ctx.fill();
    ctx.beginPath(); ctx.arc(f.x, f.y, r * p, 0, 6.28); ctx.fillStyle = 'rgba(90,190,60,0.85)'; ctx.fill();
  }
}

function renderParticles() {
  for (const p of particles) {
    const a = Math.max(0, p.life / 35);
    ctx.fillStyle = `rgba(${p.r | 0},${p.g | 0},${p.b | 0},${a.toFixed(2)})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, 6.28); ctx.fill();
  }
}

// ── Side-view ant rendering (profile view like looking through glass) ──
function renderAnt3D(ant) {
  const x = ant.x, y = ant.y + (ant.bodyBob || 0), s = ant.size;
  const facingRight = ant.vx >= 0 ? 1 : -1;
  const mov = Math.hypot(ant.vx, ant.vy) > 0.08 && !ant.isPaused;

  ctx.save();
  ctx.translate(x, y);
  ctx.scale(facingRight, 1);

  const br = 42 + ant.hue, bg = 20 + ant.hue * 0.3, bb = 12 + ant.hue * 0.2;

  // === LEGS (3 pairs, side view) ===
  ctx.strokeStyle = `rgb(${br - 8},${bg - 4},${bb - 3})`;
  ctx.lineWidth = 0.6; ctx.lineCap = 'round';

  for (let i = 0; i < 3; i++) {
    const tripodOffset = (i === 1) ? Math.PI : 0;
    const phase = mov ? Math.sin(ant.legT + tripodOffset) : 0;
    const attachX = -s * 0.4 + i * s * 0.7;
    const attachY = s * 0.15;
    const kneeX = attachX + phase * s * 0.3;
    const kneeY = attachY + s * 0.7;
    const footX = kneeX + (i - 1) * s * 0.25 + phase * s * 0.4;
    const footY = attachY + s * 1.3 + Math.abs(phase) * s * 0.15;

    ctx.beginPath();
    ctx.moveTo(attachX, attachY);
    ctx.lineTo(kneeX, kneeY);
    ctx.lineTo(footX, footY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(footX, footY);
    ctx.lineTo(footX + s * 0.15, footY + s * 0.05);
    ctx.stroke();
  }

  // === ABDOMEN ===
  const abdX = -s * 1.0, abdY = -s * 0.1;
  let g = ctx.createRadialGradient(abdX, abdY - s * 0.2, 0, abdX, abdY, s * 0.9);
  g.addColorStop(0, `rgb(${br + 25},${bg + 12},${bb + 6})`);
  g.addColorStop(0.5, `rgb(${br},${bg},${bb})`);
  g.addColorStop(1, `rgb(${br - 12},${bg - 6},${bb - 4})`);
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.ellipse(abdX, abdY, s * 1.0, s * 0.65, -0.1, 0, 6.28); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.beginPath(); ctx.ellipse(abdX + s * 0.1, abdY - s * 0.25, s * 0.4, s * 0.2, -0.2, 0, 6.28); ctx.fill();
  ctx.strokeStyle = `rgba(${br - 15},${bg - 8},${bb - 5},0.25)`; ctx.lineWidth = 0.3;
  for (let i = 0; i < 3; i++) {
    const sx2 = abdX - s * 0.4 + i * s * 0.35;
    ctx.beginPath(); ctx.moveTo(sx2, abdY - s * 0.5); ctx.quadraticCurveTo(sx2 + s * 0.05, abdY, sx2, abdY + s * 0.5); ctx.stroke();
  }

  // === PETIOLE ===
  ctx.fillStyle = `rgb(${br - 5},${bg - 3},${bb - 2})`;
  ctx.beginPath(); ctx.ellipse(-s * 0.1, s * 0.0, s * 0.15, s * 0.12, 0, 0, 6.28); ctx.fill();

  // === THORAX ===
  const thX = s * 0.35, thY = -s * 0.05;
  g = ctx.createRadialGradient(thX, thY - s * 0.15, 0, thX, thY, s * 0.5);
  g.addColorStop(0, `rgb(${br + 20},${bg + 10},${bb + 5})`);
  g.addColorStop(0.6, `rgb(${br + 3},${bg + 1},${bb})`);
  g.addColorStop(1, `rgb(${br - 8},${bg - 4},${bb - 3})`);
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.ellipse(thX, thY, s * 0.45, s * 0.35, -0.15, 0, 6.28); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.beginPath(); ctx.ellipse(thX, thY - s * 0.15, s * 0.2, s * 0.1, 0, 0, 6.28); ctx.fill();

  // === HEAD ===
  const hdX = s * 0.95, hdY = s * 0.05;
  g = ctx.createRadialGradient(hdX, hdY - s * 0.1, 0, hdX, hdY, s * 0.4);
  g.addColorStop(0, `rgb(${br + 15},${bg + 8},${bb + 4})`);
  g.addColorStop(0.6, `rgb(${br},${bg},${bb})`);
  g.addColorStop(1, `rgb(${br - 10},${bg - 5},${bb - 3})`);
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.ellipse(hdX, hdY, s * 0.38, s * 0.32, 0.1, 0, 6.28); ctx.fill();

  // Eye
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.beginPath(); ctx.arc(hdX + s * 0.18, hdY - s * 0.08, s * 0.08, 0, 6.28); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.beginPath(); ctx.arc(hdX + s * 0.2, hdY - s * 0.1, s * 0.03, 0, 6.28); ctx.fill();

  // === MANDIBLES ===
  ctx.strokeStyle = `rgb(${br - 8},${bg - 4},${bb - 3})`; ctx.lineWidth = 0.7; ctx.lineCap = 'round';
  const mO = mov ? Math.sin(ant.legT * 0.5) * 0.08 : 0;
  ctx.beginPath(); ctx.moveTo(hdX + s * 0.3, hdY - s * 0.05);
  ctx.quadraticCurveTo(hdX + s * 0.55, hdY - s * 0.15 - mO * s, hdX + s * 0.6, hdY - s * 0.02 - mO * s); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(hdX + s * 0.3, hdY + s * 0.1);
  ctx.quadraticCurveTo(hdX + s * 0.55, hdY + s * 0.2 + mO * s, hdX + s * 0.6, hdY + s * 0.08 + mO * s); ctx.stroke();

  // Sand grain in mandibles
  if (ant.carryingSand > 0) {
    ctx.fillStyle = `rgb(${SAND_R},${SAND_G},${SAND_B})`;
    ctx.beginPath(); ctx.arc(hdX + s * 0.55, hdY + s * 0.03, s * 0.18, 0, 6.28); ctx.fill();
    ctx.fillStyle = `rgba(${SAND_R + 15},${SAND_G + 10},${SAND_B + 5},0.6)`;
    ctx.beginPath(); ctx.arc(hdX + s * 0.52, hdY - s * 0.02, s * 0.08, 0, 6.28); ctx.fill();
  }

  // === ANTENNA ===
  ctx.lineWidth = 0.5; ctx.strokeStyle = `rgb(${br - 5},${bg - 3},${bb - 2})`;
  const antBob = Math.sin(ant.antT) * 0.15;
  const antExt = ant.antennateTimer > 0 ? 0.25 : 0;
  ctx.beginPath(); ctx.moveTo(hdX + s * 0.2, hdY - s * 0.2);
  ctx.quadraticCurveTo(hdX + s * 0.5, hdY - s * 0.7 + antBob * s,
    hdX + s * (0.8 + antExt), hdY - s * (0.8 - antExt * 0.3) + antBob * s);
  ctx.stroke();
  ctx.fillStyle = `rgb(${br + 5},${bg + 3},${bb + 2})`;
  ctx.beginPath(); ctx.arc(hdX + s * (0.8 + antExt), hdY - s * (0.8 - antExt * 0.3) + antBob * s, s * 0.06, 0, 6.28); ctx.fill();

  // Carrying food
  if (ant.carrying) {
    ctx.fillStyle = 'rgba(80,180,50,0.9)';
    ctx.beginPath(); ctx.arc(hdX + s * 0.5, hdY, s * 0.3, 0, 6.28); ctx.fill();
    ctx.fillStyle = 'rgba(120,220,80,0.4)';
    ctx.beginPath(); ctx.arc(hdX + s * 0.45, hdY - s * 0.08, s * 0.12, 0, 6.28); ctx.fill();
  }

  // Queen marker
  if (ant.isQueen) {
    ctx.fillStyle = 'rgba(255,200,50,0.5)';
    ctx.beginPath(); ctx.arc(abdX, abdY - s * 0.75, s * 0.2, 0, 6.28); ctx.fill();
  }

  // Hover highlight
  if (hoveredAnt === ant) {
    ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 0.8;
    ctx.beginPath(); ctx.ellipse(0, 0, s * 2.5, s * 1.8, 0, 0, 6.28); ctx.stroke();
  }

  ctx.restore();
}

function renderTandemLines() {
  ctx.strokeStyle = 'rgba(255,200,100,0.15)';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 4]);
  for (const ant of ants) {
    if (ant.tandemTargetId) {
      const target = ants.find(a => a.id === ant.tandemTargetId);
      if (target) {
        ctx.beginPath();
        ctx.moveTo(ant.x, ant.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
      }
    }
  }
  ctx.setLineDash([]);
}

function renderGlass() {
  const g = ctx.createLinearGradient(0, 0, W * 0.6, H * 0.4);
  g.addColorStop(0, 'rgba(255,255,255,0.04)'); g.addColorStop(0.4, 'rgba(255,255,255,0)');
  g.addColorStop(0.8, 'rgba(255,255,255,0.02)'); g.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = g; ctx.fillRect(FRAME, FRAME, W - FRAME * 2, H - FRAME * 3.5);
  ctx.save(); ctx.globalAlpha = 0.025; ctx.translate(W * 0.25, 0); ctx.rotate(0.25);
  ctx.fillStyle = '#fff'; ctx.fillRect(-15, 0, 30, H * 1.5); ctx.restore();
}

let renderFrame_counter = 0;

function render() {
  if (!grid) return;
  ctx.clearRect(0, 0, W, H);
  renderTerrain();
  renderSilhouette();
  renderFood();
  renderParticles();
  renderTandemLines();
  for (const ant of ants) renderAnt3D(ant);
  renderFrame();
  renderGlass();
}

// ═══════════════════════════════════════════════════════════════════
//  TOOLTIP
// ═══════════════════════════════════════════════════════════════════

function updateTooltip() {
  if (!running) return;
  const rect = canvas.getBoundingClientRect();
  const sx = W / rect.width, sy = H / rect.height;
  const cx = (mouseX - rect.left) * sx, cy = (mouseY - rect.top) * sy;
  hoveredAnt = null; let closest = 15;
  for (const ant of ants) {
    const d = Math.hypot(ant.x - cx, ant.y - cy);
    if (d < closest) { closest = d; hoveredAnt = ant; }
  }
  if (hoveredAnt) {
    const a = hoveredAnt;
    document.getElementById('ttName').textContent = a.name;
    document.getElementById('ttState').textContent = (ST_NAMES[a.state] || 'Unknown') + (a.isPaused ? ' (paused)' : '');
    document.getElementById('ttEnergy').textContent = Math.round(a.energy);
    document.getElementById('ttAge').textContent = Math.round((a.age || 0) / 60) + 's';
    document.getElementById('ttRole').textContent = a.role + (a.isQueen ? ' (queen)' : '') + (a.carryingSand > 0 ? ' [hauling]' : '');
    document.getElementById('ttThought').textContent = a.lastThought || '—';
    tooltip.classList.add('show');
    tooltip.style.left = (mouseX + 16) + 'px'; tooltip.style.top = (mouseY - 12) + 'px';
  } else tooltip.classList.remove('show');
}
document.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; updateTooltip(); });

// ═══════════════════════════════════════════════════════════════════
//  RENDER LOOP
// ═══════════════════════════════════════════════════════════════════

function tick() {
  renderFrame_counter++;

  // Interpolate ants between server snapshots
  interpolateAnts();
  tickParticles();

  // Re-render
  render();
  updateHUD();
  requestAnimationFrame(tick);
}

// ═══════════════════════════════════════════════════════════════════
//  HUD
// ═══════════════════════════════════════════════════════════════════

function updateHUD() {
  const pct = grid ? (totalDug / ((ROWS - SURFACE) * COLS) * 100).toFixed(1) : '0.0';
  document.getElementById('sAnts').textContent = ants.length;
  document.getElementById('sTunnel').textContent = pct + '%';
  document.getElementById('sChambers').textContent = chambers.length;
  document.getElementById('sDay').textContent = simDay;
}

function toast(msg) {
  const el = document.getElementById('toast'); el.textContent = msg; el.classList.add('show');
  clearTimeout(el._t); el._t = setTimeout(() => el.classList.remove('show'), 1800);
}

// ═══════════════════════════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════════════════════════

async function begin() {
  document.getElementById('intro').classList.add('hide');
  setTimeout(async () => {
    document.getElementById('intro').style.display = 'none';
    document.getElementById('app').classList.add('show');
    canvas.width = W; canvas.height = H; resizeCanvas();

    running = true;

    // Fetch initial state
    await fetchState();

    // Start render loop
    tick();

    // Start polling server
    setInterval(fetchState, POLL_INTERVAL);

    toast('Connected to live colony');
  }, 500);
}

function resizeCanvas() {
  const wrap = document.getElementById('wrap');
  const ww = wrap.clientWidth, wh = wrap.clientHeight;
  const aspect = W / H, wrapAspect = ww / wh;
  let cw, ch;
  if (wrapAspect > aspect) { ch = wh; cw = wh * aspect; } else { cw = ww; ch = ww / aspect; }
  canvas.style.width = cw + 'px'; canvas.style.height = ch + 'px';
}
window.addEventListener('resize', () => { if (running) resizeCanvas(); });
</script>
</body>
</html>
