<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Antfarm</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;1,400&family=Inter:wght@300;400;500&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #fff;
    color: #1a1a1a;
    font-family: 'Inter', -apple-system, sans-serif;
    height: 100vh;
    overflow: hidden;
    -webkit-font-smoothing: antialiased;
  }

  .intro {
    position: fixed; inset: 0; background: #fff;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 100; transition: opacity 0.8s ease;
  }
  .intro.hide { opacity: 0; pointer-events: none; }
  .intro h1 { font-family: 'EB Garamond', serif; font-size: clamp(2.5rem, 5vw, 4.5rem); font-weight: 400; margin-bottom: 12px; }
  .intro h1 em { font-style: italic; }
  .intro .sub { color: #999; font-size: 0.82rem; letter-spacing: 0.08em; margin-bottom: 48px; }
  .intro button {
    background: none; border: 1px solid #ddd; color: #1a1a1a;
    font-family: 'Inter', sans-serif; font-size: 0.78rem; letter-spacing: 0.14em;
    text-transform: uppercase; padding: 14px 44px; cursor: pointer; transition: all 0.3s;
  }
  .intro button:hover { border-color: #1a1a1a; background: #1a1a1a; color: #fff; }

  .app { display: none; height: 100vh; flex-direction: column; }
  .app.show { display: flex; }

  .topbar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 24px; height: 48px; flex-shrink: 0; border-bottom: 1px solid #eee;
  }
  .topbar .title { font-family: 'EB Garamond', serif; font-size: 1.15rem; font-weight: 400; }
  .topbar .title em { font-style: italic; }
  .topbar .stats { display: flex; gap: 24px; font-size: 0.72rem; color: #999; letter-spacing: 0.04em; }
  .topbar .stats .v { color: #1a1a1a; font-weight: 500; margin-left: 6px; font-variant-numeric: tabular-nums; }

  .canvas-wrap {
    flex: 1; position: relative; overflow: hidden;
    background: #e8e0d4; cursor: crosshair;
    display: flex; align-items: center; justify-content: center;
  }
  .canvas-wrap canvas { display: block; }

  .ant-tooltip {
    position: fixed; pointer-events: none;
    background: rgba(255,255,255,0.95); backdrop-filter: blur(8px);
    border: 1px solid #e0e0e0; padding: 8px 12px;
    font-size: 0.68rem; line-height: 1.5; color: #555;
    z-index: 50; opacity: 0; transition: opacity 0.15s ease; max-width: 180px; white-space: nowrap;
  }
  .ant-tooltip.show { opacity: 1; }
  .ant-tooltip .tt-name { color: #1a1a1a; font-weight: 500; margin-bottom: 2px; font-size: 0.72rem; }
  .ant-tooltip .tt-row { display: flex; justify-content: space-between; gap: 12px; }
  .ant-tooltip .tt-val { color: #1a1a1a; font-weight: 500; }

  .bottombar {
    display: flex; align-items: center; justify-content: center; gap: 1px;
    height: 40px; flex-shrink: 0; border-top: 1px solid #eee; background: #fff;
  }
  .bottombar button {
    background: #fff; border: none; border-right: 1px solid #eee; color: #888;
    font-family: 'Inter', sans-serif; font-size: 0.7rem; letter-spacing: 0.06em;
    padding: 0 20px; height: 100%; cursor: pointer; transition: all 0.15s;
    display: flex; align-items: center; gap: 6px;
  }
  .bottombar button:last-child { border-right: none; }
  .bottombar button:hover { background: #f8f8f8; color: #1a1a1a; }
  .bottombar .speed-label { font-variant-numeric: tabular-nums; min-width: 22px; text-align: center; color: #1a1a1a; font-weight: 500; }

  .toast {
    position: fixed; bottom: 56px; left: 50%; transform: translateX(-50%) translateY(8px);
    background: #1a1a1a; color: #fff; padding: 8px 20px; font-size: 0.72rem;
    opacity: 0; transition: all 0.25s ease; z-index: 90; pointer-events: none;
  }
  .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
</style>
</head>
<body>

<div class="intro" id="intro">
  <h1><em>Antfarm</em></h1>
  <p class="sub">a living colony simulation</p>
  <button onclick="begin()">Enter</button>
</div>

<div class="app" id="app">
  <div class="topbar">
    <div class="title"><em>Antfarm</em></div>
    <div class="stats">
      <span>Population<span class="v" id="sAnts">0</span></span>
      <span>Tunneled<span class="v" id="sTunnel">0%</span></span>
      <span>Chambers<span class="v" id="sChambers">0</span></span>
      <span>Dug<span class="v" id="sDug">0</span></span>
      <span>Day<span class="v" id="sDay">1</span></span>
    </div>
  </div>

  <div class="canvas-wrap" id="wrap">
    <canvas id="c"></canvas>
  </div>

  <div class="bottombar">
    <button onclick="dropAnts(5)"><span>+</span> 5 ants</button>
    <button onclick="dropAnts(1)"><span>+</span> 1 ant</button>
    <button onclick="dropFood()">food</button>
    <button onclick="cycleSpeed()"><span class="speed-label" id="speedLabel">1x</span></button>
    <button onclick="togglePause()" id="pauseBtn">pause</button>
  </div>
</div>

<div class="ant-tooltip" id="tooltip">
  <div class="tt-name" id="ttName"></div>
  <div class="tt-row"><span>State</span><span class="tt-val" id="ttState"></span></div>
  <div class="tt-row"><span>Energy</span><span class="tt-val" id="ttEnergy"></span></div>
  <div class="tt-row"><span>Age</span><span class="tt-val" id="ttAge"></span></div>
  <div class="tt-row"><span>Trait</span><span class="tt-val" id="ttTrait"></span></div>
</div>
<div class="toast" id="toast"></div>

<script>
// ═══════════════════════════════════════════════════════════
//  ANTFARM — Realistic Colony Simulation
// ═══════════════════════════════════════════════════════════

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

// Internal resolution
const W = 960, H = 680;
const CELL = 3; // smaller cells = smoother tunnels
const COLS = W / CELL | 0, ROWS = H / CELL | 0;
const SURFACE = Math.round(ROWS * 0.28); // sky takes ~28% of height
const SURFACE_PX = SURFACE * CELL;

// Frame border
const FRAME = 14;

// State
let grid, phTrail, phFood;
let ants = [], foods = [], particles = [], chambers = [];
let frame = 0, totalDug = 0, simDay = 1;
let speed = 1, paused = false, running = false;
let hoveredAnt = null, mouseX = 0, mouseY = 0;

// Sand noise texture (pre-generated)
let sandNoise;

// ═══════════════════════════════════════════════════════════
//  TERRAIN
// ═══════════════════════════════════════════════════════════

function hash(x, y) {
  const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
  return n - Math.floor(n);
}

function fbm(x, y) {
  return hash(x, y) * 0.5 + hash(x*2.1, y*2.3) * 0.25 + hash(x*4.7, y*4.1) * 0.125;
}

function generateSandNoise() {
  // Pre-compute a grain texture
  sandNoise = new Float32Array(W * H);
  for (let i = 0; i < sandNoise.length; i++) {
    sandNoise[i] = (Math.random() - 0.5) * 0.08;
  }
}

function initTerrain() {
  grid = new Uint8Array(COLS * ROWS);
  phTrail = new Float32Array(COLS * ROWS);
  phFood = new Float32Array(COLS * ROWS);

  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (y < SURFACE) { grid[y * COLS + x] = 0; continue; }
      const d = (y - SURFACE) / (ROWS - SURFACE);
      const n = fbm(x * 0.035, y * 0.035) - 0.4;
      grid[y * COLS + x] = Math.max(1, Math.min(5, Math.round(1 + d * 4 + n * 1.5)));
    }
  }

  // Rocks
  for (let k = 0; k < 10; k++) {
    const cx = (Math.random() * (COLS - 12) + 6) | 0;
    const cy = (Math.random() * (ROWS - SURFACE - 16) + SURFACE + 10) | 0;
    const r = 3 + (Math.random() * 4) | 0;
    for (let dy = -r; dy <= r; dy++)
      for (let dx = -r; dx <= r; dx++)
        if (dx*dx + dy*dy <= r*r) {
          const nx = cx+dx, ny = cy+dy;
          if (nx >= 0 && nx < COLS && ny >= SURFACE && ny < ROWS) grid[ny*COLS+nx] = 5;
        }
  }
}

function cell(x, y) { return (x<0||x>=COLS||y<0||y>=ROWS) ? 255 : grid[y*COLS+x]; }
function solid(x, y) { return cell(x,y) > 0; }

function dig(x, y) {
  if (x<0||x>=COLS||y<0||y>=ROWS) return false;
  const i = y*COLS+x;
  if (!grid[i]) return false;
  if (grid[i] <= 1) { grid[i]=0; totalDug++; return true; }
  grid[i]--; return false;
}

function gravity() {
  for (let y = ROWS-2; y >= SURFACE; y--) {
    for (let x = 0; x < COLS; x++) {
      const v = grid[y*COLS+x];
      if (!v || v > 2) continue;
      if (!cell(x,y+1)) { grid[(y+1)*COLS+x]=v; grid[y*COLS+x]=0; }
      else {
        const cl = !cell(x-1,y+1) && !cell(x-1,y);
        const cr = !cell(x+1,y+1) && !cell(x+1,y);
        if (cl&&cr) { const d=Math.random()<0.5?-1:1; grid[(y+1)*COLS+(x+d)]=v; grid[y*COLS+x]=0; }
        else if (cl) { grid[(y+1)*COLS+(x-1)]=v; grid[y*COLS+x]=0; }
        else if (cr) { grid[(y+1)*COLS+(x+1)]=v; grid[y*COLS+x]=0; }
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════
//  PHEROMONES
// ═══════════════════════════════════════════════════════════

function phSet(x,y,v,m) { if(x>=0&&x<COLS&&y>=0&&y<ROWS) m[y*COLS+x]=Math.min(3,m[y*COLS+x]+v); }
function phGet(x,y,m) { return (x>=0&&x<COLS&&y>=0&&y<ROWS)?m[y*COLS+x]:0; }
function phDecay() {
  for (let i = phTrail.length-1; i>=0; i--) {
    phTrail[i]*=0.9975; phFood[i]*=0.9965;
    if(phTrail[i]<0.005) phTrail[i]=0;
    if(phFood[i]<0.005) phFood[i]=0;
  }
}

// ═══════════════════════════════════════════════════════════
//  CHAMBERS
// ═══════════════════════════════════════════════════════════

function detectChambers() {
  chambers = [];
  const vis = new Uint8Array(COLS*ROWS);
  for (let y = SURFACE+4; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const i = y*COLS+x;
      if (!grid[i] && !vis[i]) {
        let n=0, sx=0, sy=0;
        const q=[[x,y]]; vis[i]=1;
        while (q.length && n<800) {
          const [cx,cy]=q.pop(); n++; sx+=cx; sy+=cy;
          for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
            const nx=cx+dx, ny=cy+dy;
            if (nx>=0&&nx<COLS&&ny>=SURFACE&&ny<ROWS) {
              const ni=ny*COLS+nx;
              if (!grid[ni]&&!vis[ni]) { vis[ni]=1; q.push([nx,ny]); }
            }
          }
        }
        if (n>=40) chambers.push({x:(sx/n)*CELL, y:(sy/n)*CELL, size:n});
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════
//  ANT AGENT
// ═══════════════════════════════════════════════════════════

const ST={WANDER:0,ENTER:1,DIG_DOWN:2,DIG_BRANCH:3,DIG_CHAMBER:4,EXPLORE:5,GO_UP:6,FORAGE:7,CARRY:8,REST:9};
const ST_NAMES=['Wandering','Entering tunnel','Digging down','Branching','Carving chamber','Exploring','Returning','Foraging','Carrying food','Resting'];
let nextId = 1;
const ANT_SPEED = 0.55;

class Ant {
  constructor(x, y) {
    this.id = nextId++;
    this.x = x; this.y = y; this.px = x; this.py = y;
    this.vx = 0; this.vy = 0;
    this.state = ST.WANDER;
    this.energy = 800 + Math.random()*200;
    this.carrying = false;
    this.age = 0; this.stuck = 0; this.digCD = 0; this.restT = 0; this.patience = 0;
    this.trait = {
      digDrive: 0.3+Math.random()*0.7, explore: Math.random(),
      follow: 0.2+Math.random()*0.6, depth: 0.15+Math.random()*0.75,
      chamber: Math.random(), bias: (Math.random()-0.5)*0.4,
    };
    this.digAngle = Math.PI*0.5;
    this.wanderAngle = Math.random()*6.28;
    this.targetX = -1; this.targetY = -1;

    const names=['Ada','Bo','Cal','Dee','Emi','Fay','Gil','Hal','Ira','Joy','Kai','Leo','Mae','Neo','Ora','Pip','Quinn','Rex','Sol','Tia','Uma','Val','Wren','Xia','Yui','Zoe'];
    this.name = names[this.id%names.length]+'-'+this.id;
    const t=this.trait;
    this.traitLabel = t.digDrive>t.explore&&t.digDrive>t.follow?'Digger':t.explore>t.follow?'Explorer':'Follower';

    this.size = 3.0 + Math.random()*0.6;
    this.hue = Math.random()*15; // slight color variation
    this.legT = Math.random()*6.28;
    this.antT = Math.random()*6.28;
  }

  gx(){return(this.x/CELL)|0;} gy(){return(this.y/CELL)|0;}
  depthR(){return Math.max(0,(this.gy()-SURFACE)/(ROWS-SURFACE));}
  atSurface(){return this.gy()<=SURFACE+1;}

  sense() {
    const gx=this.gx(),gy=this.gy();
    const s={gx,gy,surface:this.atSurface(),depth:this.depthR(),
      below:solid(gx,gy+1),above:solid(gx,gy-1),left:solid(gx-1,gy),right:solid(gx+1,gy),
      food:null,foodDist:999,phDir:null,phVal:0,nearAnts:0};
    for(const f of foods){const d=Math.hypot(f.x-this.x,f.y-this.y);if(d<50&&d<s.foodDist){s.food=f;s.foodDist=d;}}
    let best=0,bestA=null;const m=this.carrying?phTrail:phFood;
    for(let a=0;a<6.28;a+=0.785){const v=phGet(gx+Math.round(Math.cos(a)*3),gy+Math.round(Math.sin(a)*3),m);if(v>best){best=v;bestA=a;}}
    s.phVal=best;s.phDir=bestA;
    for(const a of ants)if(a!==this&&Math.hypot(a.x-this.x,a.y-this.y)<30)s.nearAnts++;
    return s;
  }

  think(s) {
    if(this.energy<40){this.state=ST.REST;return;}
    if(this.state===ST.REST){this.restT++;this.energy+=0.8;if(this.restT>80||this.energy>300){this.restT=0;this.state=ST.WANDER;}return;}
    if(this.carrying){this.state=ST.CARRY;return;}
    if(s.food&&!this.carrying){this.state=ST.FORAGE;this.targetX=s.food.x;this.targetY=s.food.y;return;}
    if(s.surface){
      if(this.carrying)this.carrying=false;
      if(s.phVal>0.15&&this.trait.follow>0.4){this.state=ST.FORAGE;return;}
      this.patience++;
      const thresh=100*(1-this.trait.digDrive*0.6);
      if(this.patience>thresh){
        this.patience=0;
        let entrance=null;
        for(let dx=-40;dx<=40;dx+=2){const ex=this.gx()+dx;
          if(ex>=0&&ex<COLS&&!cell(ex,SURFACE+1)&&!cell(ex,SURFACE+2)){if(!entrance||Math.abs(dx)<Math.abs(entrance))entrance=dx;}}
        if(entrance!==null&&Math.random()<this.trait.follow){this.targetX=(this.gx()+entrance)*CELL;this.state=ST.ENTER;}
        else{this.state=ST.DIG_DOWN;this.digAngle=Math.PI*0.5+this.trait.bias;}
        return;
      }
      this.state=ST.WANDER;return;
    }
    if(this.state===ST.DIG_DOWN||this.state===ST.DIG_BRANCH||this.state===ST.DIG_CHAMBER){
      if(s.depth>this.trait.depth&&this.state===ST.DIG_DOWN){
        if(Math.random()<this.trait.chamber*0.4){this.state=ST.DIG_CHAMBER;this.patience=0;}
        else if(Math.random()<0.5){this.state=ST.DIG_BRANCH;this.digAngle=(Math.random()<0.5?0:Math.PI)+(Math.random()-0.5)*0.6;}
        else this.state=ST.EXPLORE;return;}
      if(this.state===ST.DIG_CHAMBER){this.patience++;if(this.patience>80+Math.random()*60){this.state=Math.random()<0.4?ST.GO_UP:ST.EXPLORE;this.patience=0;}return;}
      if(this.state===ST.DIG_BRANCH){if(Math.random()<0.008)this.digAngle+=(Math.random()-0.5)*1.0;if(Math.random()<0.006)this.state=Math.random()<0.5?ST.GO_UP:ST.EXPLORE;return;}
      if(Math.random()<0.015){this.digAngle+=(Math.random()-0.5)*0.5;this.digAngle=Math.max(0.2,Math.min(Math.PI-0.2,this.digAngle));}return;
    }
    if(this.state===ST.EXPLORE){
      if(s.phVal>0.2&&Math.random()<this.trait.follow)this.wanderAngle=s.phDir;
      if(Math.random()<0.003){this.state=this.trait.digDrive>0.5&&Math.random()<0.5?ST.DIG_BRANCH:ST.GO_UP;this.digAngle=this.wanderAngle+(Math.random()-0.5)*1.2;}return;
    }
    if(this.state===ST.GO_UP||this.state===ST.CARRY){if(s.surface){this.state=ST.WANDER;this.patience=0;if(this.carrying)this.carrying=false;}return;}
    this.state=ST.EXPLORE;
  }

  act(s) {
    this.age++;this.energy-=0.12;
    const mov=this.state!==ST.REST;
    this.legT+=mov?0.18:0;this.antT+=0.06;
    if(this.digCD>0)this.digCD--;
    const gx=s.gx,gy=s.gy;
    if(this.carrying)phSet(gx,gy,0.6,phFood);
    phSet(gx,gy,0.12,phTrail);

    switch(this.state){
      case ST.WANDER:this._wander(s);break;
      case ST.ENTER:this._enter(s);break;
      case ST.DIG_DOWN:case ST.DIG_BRANCH:this._digTunnel(s);break;
      case ST.DIG_CHAMBER:this._digChamber(s);break;
      case ST.EXPLORE:this._explore(s);break;
      case ST.GO_UP:case ST.CARRY:this._goUp(s);break;
      case ST.FORAGE:this._forage(s);break;
    }

    if(!this.carrying){for(let i=foods.length-1;i>=0;i--){if(Math.hypot(foods[i].x-this.x,foods[i].y-this.y)<CELL*2.5){foods[i].amount--;if(foods[i].amount<=0)foods.splice(i,1);this.carrying=true;this.energy=Math.min(1000,this.energy+400);this.state=ST.CARRY;break;}}}
    if(this.carrying&&s.surface){this.carrying=false;this.state=ST.WANDER;}

    if(!s.below&&gy<ROWS-1)this.vy+=0.1;
    if((s.left||s.right)&&!s.below)this.vy*=0.4;
    const maxV=ANT_SPEED*3.5;
    this.vx=Math.max(-maxV,Math.min(maxV,this.vx));
    this.vy=Math.max(-maxV,Math.min(maxV,this.vy));
    this.px=this.x;this.py=this.y;
    let nx=this.x+this.vx,ny=this.y+this.vy;
    const ngx=(nx/CELL)|0,ngy=(ny/CELL)|0;
    const digging=this.state===ST.DIG_DOWN||this.state===ST.DIG_BRANCH||this.state===ST.DIG_CHAMBER;
    if(solid(ngx,ngy)&&!digging){
      if(!solid(gx,ngy)){nx=this.x;this.vx*=0.2;}
      else if(!solid(ngx,gy)){ny=this.y;this.vy*=0.2;}
      else{nx=this.x;ny=this.y;this.vx*=0.1;this.vy*=0.1;this.stuck++;}
    }else this.stuck=0;
    if(this.stuck>40){this._unstick(gx,gy);this.stuck=0;}
    this.x=Math.max(CELL,Math.min(W-CELL,nx));
    this.y=Math.max(CELL,Math.min(H-CELL,ny));
  }

  _wander(s){this.wanderAngle+=(Math.random()-0.5)*0.2;this.vx+=Math.cos(this.wanderAngle)*ANT_SPEED*0.4;if(this.y<SURFACE_PX-CELL*2)this.vy+=0.12;if(this.y>SURFACE_PX+CELL)this.vy-=0.12;if(this.x<CELL*4)this.wanderAngle=0;if(this.x>W-CELL*4)this.wanderAngle=Math.PI;this.vx*=0.91;this.vy*=0.91;}
  _enter(s){if(this.targetX>=0){const dx=this.targetX-this.x;if(Math.abs(dx)>CELL*2)this.vx+=Math.sign(dx)*ANT_SPEED*0.5;else{this.vy+=ANT_SPEED*0.5;this.state=ST.EXPLORE;this.targetX=-1;}}this.vx*=0.9;this.vy*=0.9;}

  _digTunnel(s){
    const dx=Math.cos(this.digAngle),dy=Math.sin(this.digAngle);
    this.vx+=dx*ANT_SPEED*0.25;this.vy+=dy*ANT_SPEED*0.35;this.vx*=0.82;this.vy*=0.82;
    if(this.digCD<=0){
      const fwdX=s.gx+Math.round(dx*1.5),fwdY=s.gy+Math.round(dy*1.5);
      // Wider tunnels with smoother edges
      for(let ddx=-2;ddx<=2;ddx++)for(let ddy=-2;ddy<=2;ddy++)
        if(ddx*ddx+ddy*ddy<=4)dig(fwdX+ddx,fwdY+ddy);
      // Extra width
      if(Math.random()<0.5){
        for(let ddx=-3;ddx<=3;ddx++)for(let ddy=-3;ddy<=3;ddy++)
          if(ddx*ddx+ddy*ddy<=8&&Math.random()<0.3)dig(fwdX+ddx,fwdY+ddy);
      }
      this.digCD=2+(Math.random()*2)|0;this.energy-=0.3;
      phSet(s.gx,s.gy,0.5,phTrail);
      if(Math.random()<0.3)spawnDirt(fwdX*CELL,fwdY*CELL);
    }
  }

  _digChamber(s){
    this.wanderAngle+=0.05+Math.random()*0.04;
    this.vx+=Math.cos(this.wanderAngle)*ANT_SPEED*0.35;this.vy+=Math.sin(this.wanderAngle)*ANT_SPEED*0.35;
    this.vx*=0.8;this.vy*=0.8;
    if(this.digCD<=0){
      for(let ddx=-3;ddx<=3;ddx++)for(let ddy=-3;ddy<=3;ddy++)
        if(ddx*ddx+ddy*ddy<=9&&Math.random()<0.5)dig(s.gx+ddx,s.gy+ddy);
      this.digCD=2;this.energy-=0.4;if(Math.random()<0.3)spawnDirt(this.x,this.y);
    }
  }

  _explore(s){
    this.wanderAngle+=(Math.random()-0.5)*0.4;
    const tx=s.gx+Math.round(Math.cos(this.wanderAngle)*2),ty=s.gy+Math.round(Math.sin(this.wanderAngle)*2);
    if(!solid(tx,ty)){this.vx+=Math.cos(this.wanderAngle)*ANT_SPEED*0.4;this.vy+=Math.sin(this.wanderAngle)*ANT_SPEED*0.3;}
    else{this.wanderAngle+=Math.PI*0.5+(Math.random()-0.5);if(Math.random()<this.trait.digDrive*0.1&&this.digCD<=0){dig(tx,ty);this.digCD=10;}}
    if(s.left&&!s.right)this.vx+=0.08;if(s.right&&!s.left)this.vx-=0.08;
    this.vx*=0.86;this.vy*=0.86;
  }

  _goUp(s){
    this.vy-=ANT_SPEED*0.35;let best=-Math.PI/2,bestS=-999;
    for(let a=-Math.PI;a<Math.PI;a+=0.52){const cx=s.gx+Math.round(Math.cos(a)*2),cy=s.gy+Math.round(Math.sin(a)*2);
      if(!solid(cx,cy)){const sc=-Math.sin(a)*2+phGet(cx,cy,phTrail)*0.5;if(sc>bestS){bestS=sc;best=a;}}}
    this.vx+=Math.cos(best)*ANT_SPEED*0.4;this.vy+=Math.sin(best)*ANT_SPEED*0.4;
    if(this.stuck>12&&this.digCD<=0){dig(s.gx,s.gy-1);dig(s.gx,s.gy-2);this.digCD=4;}
    this.vx*=0.86;this.vy*=0.86;
  }

  _forage(s){
    if(this.targetX>=0){const dx=this.targetX-this.x,dy=this.targetY-this.y,d=Math.hypot(dx,dy);if(d>3){this.vx+=(dx/d)*ANT_SPEED*0.6;this.vy+=(dy/d)*ANT_SPEED*0.6;}}
    else if(s.phDir!==null){this.vx+=Math.cos(s.phDir)*ANT_SPEED*0.4;this.vy+=Math.sin(s.phDir)*ANT_SPEED*0.4;}
    this.vx*=0.88;this.vy*=0.88;
  }

  _unstick(gx,gy){
    const seen=new Set(),q=[[gx,gy]];seen.add(gx+','+gy);
    while(q.length){const[cx,cy]=q.shift();if(!solid(cx,cy)&&cy>=0&&cy<ROWS){this.x=cx*CELL+CELL/2;this.y=cy*CELL+CELL/2;this.vx=this.vy=0;return;}
    for(const[dx,dy]of[[-1,0],[1,0],[0,-1],[0,1]]){const nx=cx+dx,ny=cy+dy,k=nx+','+ny;if(!seen.has(k)&&nx>=0&&nx<COLS&&ny>=0&&ny<ROWS){seen.add(k);q.push([nx,ny]);}}if(seen.size>200)break;}
  }

  update(){const s=this.sense();this.think(s);this.act(s);}
}

// ═══════════════════════════════════════════════════════════
//  PARTICLES
// ═══════════════════════════════════════════════════════════

function spawnDirt(x,y){
  for(let i=0;i<3;i++)
    particles.push({x:x+Math.random()*CELL,y:y+Math.random()*CELL,vx:(Math.random()-0.5)*1.5,vy:-Math.random()*1.2-0.4,life:22+Math.random()*18,size:1+Math.random()*1.5,r:200+Math.random()*30,g:180+Math.random()*20,b:140+Math.random()*20});
}
function tickParticles(){for(let i=particles.length-1;i>=0;i--){const p=particles[i];p.x+=p.vx;p.y+=p.vy;p.vy+=0.06;p.vx*=0.97;if(--p.life<=0)particles.splice(i,1);}}

// ═══════════════════════════════════════════════════════════
//  RENDERING — Smooth, realistic
// ═══════════════════════════════════════════════════════════

// We use an offscreen canvas for the terrain to apply blur
const terrainCanvas = document.createElement('canvas');
terrainCanvas.width = W; terrainCanvas.height = H;
const tctx = terrainCanvas.getContext('2d');
const tImg = new ImageData(W, H);

// Sand colors matching reference — warm tan/beige
const SAND_BASE = [210, 190, 155]; // base sand color
const SAND_DARK = [185, 165, 128]; // slightly darker
const SAND_DEEP = [170, 148, 112]; // deeper

function renderTerrain() {
  const d = tImg.data;

  // Sky — light warm white/gray
  for (let y = 0; y < SURFACE_PX; y++) {
    const t = y / SURFACE_PX;
    for (let x = 0; x < W; x++) {
      const i = (y*W+x)*4;
      d[i] = 235 + t*5;   // warm white
      d[i+1] = 232 + t*5;
      d[i+2] = 225 + t*5;
      d[i+3] = 255;
    }
  }

  // Ground with sand texture
  for (let gy = SURFACE; gy < ROWS; gy++) {
    for (let gx = 0; gx < COLS; gx++) {
      const v = grid[gy*COLS+gx];
      const px = gx*CELL, py = gy*CELL;
      const depthT = (gy-SURFACE)/(ROWS-SURFACE);

      if (v > 0) {
        // Sand color — warm tan, gets slightly darker with depth
        const depthDarken = 1 - depthT * 0.18;
        let baseR = (SAND_BASE[0] - depthT * 30) * depthDarken;
        let baseG = (SAND_BASE[1] - depthT * 30) * depthDarken;
        let baseB = (SAND_BASE[2] - depthT * 25) * depthDarken;

        // Edge detection for tunnel borders — darker edges
        const aboveAir = cell(gx,gy-1)===0 && gy > SURFACE;
        const belowAir = cell(gx,gy+1)===0;
        const leftAir = cell(gx-1,gy)===0;
        const rightAir = cell(gx+1,gy)===0;
        const nearAir = aboveAir||belowAir||leftAir||rightAir;

        // Diagonal neighbors for smoother detection
        const diagAir = (cell(gx-1,gy-1)===0)||(cell(gx+1,gy-1)===0)||
                        (cell(gx-1,gy+1)===0)||(cell(gx+1,gy+1)===0);

        for (let dy = 0; dy < CELL; dy++) {
          for (let dx = 0; dx < CELL; dx++) {
            const sx = px+dx, sy = py+dy;
            const i = (sy*W+sx)*4;

            let r = baseR, g = baseG, b = baseB;

            // Sand grain noise
            const noise = sandNoise[sy*W+sx] || 0;
            r += noise * 30;
            g += noise * 25;
            b += noise * 20;

            // Tunnel edge shading — creates smooth shadow border
            if (nearAir || diagAir) {
              let edgeDist = 99;
              if (aboveAir) edgeDist = Math.min(edgeDist, dy);
              if (belowAir) edgeDist = Math.min(edgeDist, CELL-1-dy);
              if (leftAir) edgeDist = Math.min(edgeDist, dx);
              if (rightAir) edgeDist = Math.min(edgeDist, CELL-1-dx);

              const shadow = Math.max(0, 1 - edgeDist / CELL) * 0.35;
              r *= (1 - shadow);
              g *= (1 - shadow);
              b *= (1 - shadow);
            }

            d[i] = Math.max(0,Math.min(255,r));
            d[i+1] = Math.max(0,Math.min(255,g));
            d[i+2] = Math.max(0,Math.min(255,b));
            d[i+3] = 255;
          }
        }
      } else if (gy >= SURFACE) {
        // Tunnel interior — dark with very subtle pheromone tint
        for (let dy = 0; dy < CELL; dy++) {
          for (let dx = 0; dx < CELL; dx++) {
            const sx = px+dx, sy = py+dy;
            const i = (sy*W+sx)*4;
            const ph = phTrail[gy*COLS+gx];
            const fp = phFood[gy*COLS+gx];
            // Dark brown-black tunnel interior
            d[i] = Math.min(35, 12 + ph*8 + fp*4);
            d[i+1] = Math.min(30, 8 + ph*3 + fp*12);
            d[i+2] = Math.min(28, 6 + ph*10 + fp*3);
            d[i+3] = 255;
          }
        }
      }
    }
  }

  tctx.putImageData(tImg, 0, 0);

  // Slight blur pass for smooth edges
  ctx.filter = 'blur(0.5px)';
  ctx.drawImage(terrainCanvas, 0, 0);
  ctx.filter = 'none';
}

function renderFrame() {
  // Green plastic frame like the reference toy
  const green = '#2d8c3c';
  const greenDark = '#1e6b2b';
  const greenLight = '#3aad4d';

  ctx.save();

  // Top frame
  ctx.fillStyle = green;
  ctx.fillRect(0, 0, W, FRAME);

  // Bottom frame
  ctx.fillRect(0, H - FRAME * 2.5, W, FRAME * 2.5);

  // Left frame
  ctx.fillRect(0, 0, FRAME, H);

  // Right frame
  ctx.fillRect(W - FRAME, 0, FRAME, H);

  // Corner bolts
  const boltR = 5;
  const boltPositions = [
    [FRAME/2, FRAME/2], [W-FRAME/2, FRAME/2],
    [FRAME/2, H-FRAME*1.5], [W-FRAME/2, H-FRAME*1.5],
    [FRAME/2, H*0.35], [W-FRAME/2, H*0.35],
    [FRAME/2, H*0.65], [W-FRAME/2, H*0.65],
  ];
  for (const [bx, by] of boltPositions) {
    ctx.beginPath(); ctx.arc(bx, by, boltR, 0, 6.28);
    ctx.fillStyle = greenDark; ctx.fill();
    ctx.beginPath(); ctx.arc(bx-1, by-1, boltR*0.6, 0, 6.28);
    ctx.fillStyle = greenLight; ctx.fill();
  }

  // "ANT FARM" text on bottom
  ctx.fillStyle = greenLight;
  ctx.font = 'bold 13px Inter, sans-serif';
  ctx.letterSpacing = '4px';
  ctx.textAlign = 'center';
  ctx.fillText('ANT FARM', W/2, H - FRAME * 0.6);

  // Top holes (ventilation)
  for (let i = 0; i < 7; i++) {
    const hx = W * 0.35 + i * 12;
    ctx.beginPath(); ctx.arc(hx, FRAME * 0.5, 2, 0, 6.28);
    ctx.fillStyle = greenDark; ctx.fill();
  }

  // 3D frame highlights
  ctx.strokeStyle = greenLight;
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(FRAME, 1); ctx.lineTo(W-FRAME, 1); ctx.stroke(); // top highlight
  ctx.beginPath(); ctx.moveTo(1, FRAME); ctx.lineTo(1, H-FRAME*2.5); ctx.stroke(); // left highlight

  ctx.strokeStyle = greenDark;
  ctx.beginPath(); ctx.moveTo(FRAME, FRAME-1); ctx.lineTo(W-FRAME, FRAME-1); ctx.stroke(); // top inner shadow
  ctx.beginPath(); ctx.moveTo(W-2, FRAME); ctx.lineTo(W-2, H-FRAME*2.5); ctx.stroke(); // right shadow

  ctx.restore();
}

function renderSilhouette() {
  // Green farm scene silhouette along the surface, inside the frame
  const y = SURFACE_PX;
  const left = FRAME;
  const right = W - FRAME;

  ctx.save();
  ctx.fillStyle = '#2a8a38';

  // Ground line
  ctx.fillRect(left, y - 2, right - left, 4);

  // Rolling hills
  ctx.beginPath();
  ctx.moveTo(left, y);
  for (let x = left; x <= right; x++) {
    const hill = Math.sin((x - left) * 0.008) * 6 + Math.sin((x - left) * 0.02) * 3;
    ctx.lineTo(x, y - hill - 2);
  }
  ctx.lineTo(right, y); ctx.closePath(); ctx.fill();

  // Barn (left side)
  const barnX = left + 80;
  ctx.fillRect(barnX, y - 30, 35, 28);
  ctx.beginPath(); ctx.moveTo(barnX - 3, y - 30); ctx.lineTo(barnX + 17, y - 46); ctx.lineTo(barnX + 38, y - 30); ctx.closePath(); ctx.fill();
  // Barn door
  ctx.fillStyle = '#1e6b2b';
  ctx.fillRect(barnX + 12, y - 16, 10, 14);
  ctx.fillStyle = '#2a8a38';

  // Farmhouse
  const houseX = left + 160;
  ctx.fillRect(houseX, y - 25, 28, 23);
  ctx.beginPath(); ctx.moveTo(houseX - 2, y - 25); ctx.lineTo(houseX + 14, y - 38); ctx.lineTo(houseX + 30, y - 25); ctx.closePath(); ctx.fill();
  // Chimney
  ctx.fillRect(houseX + 22, y - 42, 5, 16);
  // Window
  ctx.fillStyle = '#1e6b2b';
  ctx.fillRect(houseX + 8, y - 20, 6, 6);
  ctx.fillRect(houseX + 17, y - 20, 6, 6);
  ctx.fillStyle = '#2a8a38';

  // Windmill
  const wmX = right - 200;
  ctx.fillRect(wmX, y - 40, 6, 38);
  // Blades
  const bladeAngle = frame * 0.008;
  ctx.save();
  ctx.translate(wmX + 3, y - 40);
  ctx.rotate(bladeAngle);
  for (let i = 0; i < 4; i++) {
    ctx.rotate(Math.PI / 2);
    ctx.fillRect(-2, 0, 4, 18);
  }
  ctx.restore();

  // Silo
  const siloX = right - 120;
  ctx.fillRect(siloX, y - 38, 16, 36);
  ctx.beginPath(); ctx.arc(siloX + 8, y - 38, 8, Math.PI, 0); ctx.fill();
  // Silo top
  ctx.beginPath(); ctx.moveTo(siloX + 5, y - 44); ctx.lineTo(siloX + 8, y - 52); ctx.lineTo(siloX + 11, y - 44); ctx.closePath(); ctx.fill();

  // Big barn (right)
  const barn2X = right - 80;
  ctx.fillRect(barn2X, y - 32, 40, 30);
  ctx.beginPath(); ctx.moveTo(barn2X - 3, y - 32); ctx.lineTo(barn2X + 20, y - 48); ctx.lineTo(barn2X + 43, y - 32); ctx.closePath(); ctx.fill();
  // Barn window
  ctx.fillStyle = '#1e6b2b';
  ctx.beginPath(); ctx.arc(barn2X + 20, y - 36, 5, Math.PI, 0); ctx.fill();
  ctx.fillStyle = '#2a8a38';

  // Trees (scattered)
  const trees = [left+30, left+250, left+350, right-260, right-160];
  for (const tx of trees) {
    // Trunk
    ctx.fillRect(tx, y - 18, 3, 16);
    // Canopy
    ctx.beginPath(); ctx.arc(tx + 1.5, y - 22, 9, 0, 6.28); ctx.fill();
  }

  // Fence posts
  for (let fx = left + 300; fx < left + 420; fx += 15) {
    ctx.fillRect(fx, y - 10, 2, 8);
  }
  ctx.fillRect(left + 300, y - 8, 120, 1.5);
  ctx.fillRect(left + 300, y - 5, 120, 1.5);

  ctx.restore();
}

function renderFood() {
  for (const f of foods) {
    const p = 1+Math.sin(frame*0.05)*0.12;
    const r = 3+f.amount*0.8;
    ctx.beginPath();ctx.arc(f.x,f.y,r*2*p,0,6.28);ctx.fillStyle='rgba(70,170,50,0.06)';ctx.fill();
    ctx.beginPath();ctx.arc(f.x,f.y,r*p,0,6.28);ctx.fillStyle='rgba(90,190,60,0.85)';ctx.fill();
  }
}

function renderParticles() {
  for (const p of particles) {
    const a=Math.max(0,p.life/40);
    ctx.fillStyle=`rgba(${p.r|0},${p.g|0},${p.b|0},${a.toFixed(2)})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, 6.28); ctx.fill();
  }
}

// ── 3D Ant Rendering ──
function renderAnt3D(ant) {
  const x = ant.x, y = ant.y, s = ant.size;
  const angle = Math.atan2(ant.vy, ant.vx);
  const mov = Math.hypot(ant.vx, ant.vy) > 0.08;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(0, s*0.5, s*2.2, s*0.4, 0, 0, 6.28);
  ctx.fill();

  const baseR = 38 + ant.hue;
  const baseG = 18 + ant.hue * 0.3;
  const baseB = 10 + ant.hue * 0.2;

  // Legs (behind body)
  ctx.strokeStyle = `rgb(${baseR-5},${baseG-3},${baseB-2})`;
  ctx.lineWidth = 0.7;
  ctx.lineCap = 'round';
  for (let i = 0; i < 3; i++) {
    const ph = mov ? Math.sin(ant.legT + i * 1.1) * 0.42 : 0.2;
    const lx = -s*0.5 + i*s*0.55;
    // Right legs
    ctx.beginPath();
    ctx.moveTo(lx, s*0.15);
    const knee1X = lx + Math.cos(ph+0.7)*s*0.8;
    const knee1Y = s*0.7 + Math.sin(ph)*s*0.3;
    const foot1X = lx + Math.cos(ph+0.9)*s*1.5;
    const foot1Y = s*1.1 + Math.sin(ph)*s*0.4;
    ctx.quadraticCurveTo(knee1X, knee1Y, foot1X, foot1Y);
    ctx.stroke();
    // Left legs
    ctx.beginPath();
    ctx.moveTo(lx, -s*0.15);
    ctx.quadraticCurveTo(lx+Math.cos(-ph-0.7)*s*0.8, -s*0.7-Math.sin(ph)*s*0.3,
                         lx+Math.cos(-ph-0.9)*s*1.5, -s*1.1-Math.sin(ph)*s*0.4);
    ctx.stroke();
  }

  // Abdomen (3D with gradient)
  const abdGrad = ctx.createRadialGradient(-s*1.0, -s*0.25, 0, -s*1.3, 0, s*1.2);
  abdGrad.addColorStop(0, `rgb(${baseR+30},${baseG+15},${baseB+8})`); // highlight
  abdGrad.addColorStop(0.4, `rgb(${baseR},${baseG},${baseB})`);
  abdGrad.addColorStop(1, `rgb(${baseR-15},${baseG-8},${baseB-5})`); // shadow
  ctx.fillStyle = abdGrad;
  ctx.beginPath(); ctx.ellipse(-s*1.3, 0, s*1.15, s*0.8, 0, 0, 6.28); ctx.fill();

  // Abdomen specular highlight
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.beginPath(); ctx.ellipse(-s*1.1, -s*0.3, s*0.5, s*0.25, -0.3, 0, 6.28); ctx.fill();

  // Abdomen stripes (subtle)
  ctx.strokeStyle = `rgba(${baseR-10},${baseG-6},${baseB-4},0.3)`;
  ctx.lineWidth = 0.3;
  for (let i = 0; i < 3; i++) {
    const sx = -s*1.6 + i*s*0.35;
    ctx.beginPath(); ctx.ellipse(sx, 0, s*0.12, s*0.6, 0.1, 0, 6.28); ctx.stroke();
  }

  // Petiole (waist)
  ctx.fillStyle = `rgb(${baseR-5},${baseG-3},${baseB-2})`;
  ctx.beginPath(); ctx.ellipse(-s*0.25, 0, s*0.22, s*0.22, 0, 0, 6.28); ctx.fill();

  // Thorax (3D)
  const thGrad = ctx.createRadialGradient(s*0.1, -s*0.2, 0, 0, 0, s*0.7);
  thGrad.addColorStop(0, `rgb(${baseR+25},${baseG+12},${baseB+6})`);
  thGrad.addColorStop(0.5, `rgb(${baseR+5},${baseG+2},${baseB+1})`);
  thGrad.addColorStop(1, `rgb(${baseR-10},${baseG-5},${baseB-3})`);
  ctx.fillStyle = thGrad;
  ctx.beginPath(); ctx.ellipse(s*0.15, 0, s*0.55, s*0.48, 0, 0, 6.28); ctx.fill();

  // Thorax highlight
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.beginPath(); ctx.ellipse(s*0.2, -s*0.18, s*0.25, s*0.15, -0.2, 0, 6.28); ctx.fill();

  // Head (3D)
  const hdGrad = ctx.createRadialGradient(s*1.1, -s*0.15, 0, s*0.95, 0, s*0.6);
  hdGrad.addColorStop(0, `rgb(${baseR+20},${baseG+10},${baseB+5})`);
  hdGrad.addColorStop(0.6, `rgb(${baseR},${baseG},${baseB})`);
  hdGrad.addColorStop(1, `rgb(${baseR-12},${baseG-6},${baseB-3})`);
  ctx.fillStyle = hdGrad;
  ctx.beginPath(); ctx.ellipse(s*0.95, 0, s*0.5, s*0.42, 0, 0, 6.28); ctx.fill();

  // Head highlight
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.beginPath(); ctx.ellipse(s*1.0, -s*0.15, s*0.2, s*0.12, -0.2, 0, 6.28); ctx.fill();

  // Eyes
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.beginPath(); ctx.arc(s*1.2, -s*0.2, s*0.1, 0, 6.28); ctx.fill();
  ctx.beginPath(); ctx.arc(s*1.2, s*0.2, s*0.1, 0, 6.28); ctx.fill();
  // Eye glint
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.beginPath(); ctx.arc(s*1.22, -s*0.22, s*0.04, 0, 6.28); ctx.fill();
  ctx.beginPath(); ctx.arc(s*1.22, s*0.18, s*0.04, 0, 6.28); ctx.fill();

  // Mandibles
  ctx.strokeStyle = `rgb(${baseR-10},${baseG-5},${baseB-3})`;
  ctx.lineWidth = 0.8;
  ctx.lineCap = 'round';
  const mOpen = mov ? Math.sin(ant.legT * 0.3) * 0.1 : 0;
  ctx.beginPath(); ctx.moveTo(s*1.4, -s*0.12); ctx.quadraticCurveTo(s*1.65, -s*0.22-mOpen*s, s*1.8, -s*0.15-mOpen*s); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(s*1.4, s*0.12); ctx.quadraticCurveTo(s*1.65, s*0.22+mOpen*s, s*1.8, s*0.15+mOpen*s); ctx.stroke();

  // Antennae (with subtle animation)
  ctx.lineWidth = 0.5;
  ctx.strokeStyle = `rgb(${baseR-5},${baseG-3},${baseB-2})`;
  const a1 = Math.sin(ant.antT)*0.2, a2 = Math.sin(ant.antT+0.8)*0.2;
  ctx.beginPath();
  ctx.moveTo(s*1.3, -s*0.22);
  ctx.quadraticCurveTo(s*1.6, -s*0.7+a1*s, s*1.9, -s*0.95+a1*s);
  ctx.lineTo(s*2.15, -s*0.8+a1*s);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(s*1.3, s*0.22);
  ctx.quadraticCurveTo(s*1.6, s*0.7+a2*s, s*1.9, s*0.95+a2*s);
  ctx.lineTo(s*2.15, s*0.8+a2*s);
  ctx.stroke();

  // Antenna tips (small bulbs)
  ctx.fillStyle = `rgb(${baseR+10},${baseG+5},${baseB+3})`;
  ctx.beginPath(); ctx.arc(s*2.15, -s*0.8+a1*s, s*0.08, 0, 6.28); ctx.fill();
  ctx.beginPath(); ctx.arc(s*2.15, s*0.8+a2*s, s*0.08, 0, 6.28); ctx.fill();

  // Carrying food
  if (ant.carrying) {
    ctx.fillStyle = 'rgba(80,180,50,0.9)';
    ctx.beginPath(); ctx.arc(s*1.7, 0, s*0.35, 0, 6.28); ctx.fill();
    ctx.fillStyle = 'rgba(120,220,80,0.4)';
    ctx.beginPath(); ctx.arc(s*1.65, -s*0.1, s*0.15, 0, 6.28); ctx.fill();
  }

  // Highlight if hovered
  if (hoveredAnt === ant) {
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 0.8;
    ctx.beginPath(); ctx.ellipse(0, 0, s*2.5, s*1.8, 0, 0, 6.28); ctx.stroke();
  }

  ctx.restore();
}

function renderAnts() {
  for (const ant of ants) renderAnt3D(ant);
}

// ── Glass reflection over the whole farm ──
function renderGlass() {
  // Subtle glass reflection — diagonal shine
  ctx.save();
  const glassGrad = ctx.createLinearGradient(0, 0, W*0.6, H*0.4);
  glassGrad.addColorStop(0, 'rgba(255,255,255,0.04)');
  glassGrad.addColorStop(0.4, 'rgba(255,255,255,0)');
  glassGrad.addColorStop(0.6, 'rgba(255,255,255,0)');
  glassGrad.addColorStop(0.8, 'rgba(255,255,255,0.02)');
  glassGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = glassGrad;
  ctx.fillRect(FRAME, FRAME, W-FRAME*2, H-FRAME*3.5);

  // Shine streak
  ctx.save();
  ctx.globalAlpha = 0.03;
  ctx.translate(W*0.25, 0);
  ctx.rotate(0.25);
  ctx.fillStyle = '#fff';
  ctx.fillRect(-15, 0, 30, H*1.5);
  ctx.restore();

  ctx.restore();
}

function render() {
  ctx.clearRect(0, 0, W, H);
  renderTerrain();
  renderSilhouette();
  renderFood();
  renderParticles();
  renderAnts();
  renderFrame();
  renderGlass();
}

// ═══════════════════════════════════════════════════════════
//  TOOLTIP
// ═══════════════════════════════════════════════════════════

function updateTooltip() {
  if (!running) return;
  const wrap = document.getElementById('wrap');
  const rect = canvas.getBoundingClientRect();
  const sx = W/rect.width, sy = H/rect.height;
  const cx = (mouseX-rect.left)*sx, cy = (mouseY-rect.top)*sy;

  hoveredAnt = null;
  let closest = 15;
  for (const ant of ants) {
    const d = Math.hypot(ant.x-cx, ant.y-cy);
    if (d < closest) { closest = d; hoveredAnt = ant; }
  }

  if (hoveredAnt) {
    const a = hoveredAnt;
    document.getElementById('ttName').textContent = a.name;
    document.getElementById('ttState').textContent = ST_NAMES[a.state];
    document.getElementById('ttEnergy').textContent = Math.round(a.energy);
    document.getElementById('ttAge').textContent = Math.round(a.age/60)+'s';
    document.getElementById('ttTrait').textContent = a.traitLabel;
    tooltip.classList.add('show');
    tooltip.style.left = (mouseX+16)+'px';
    tooltip.style.top = (mouseY-12)+'px';
  } else {
    tooltip.classList.remove('show');
  }
}

document.addEventListener('mousemove', e => { mouseX=e.clientX; mouseY=e.clientY; updateTooltip(); });

// ═══════════════════════════════════════════════════════════
//  GAME LOOP
// ═══════════════════════════════════════════════════════════

function tick() {
  if (!paused) {
    for (let s = 0; s < speed; s++) {
      for (const ant of ants) ant.update();
      if (frame%4===0) gravity();
      if (frame%12===0) phDecay();
      tickParticles();
      for (let i=ants.length-1;i>=0;i--) if(ants[i].energy<=0) ants.splice(i,1);
      frame++;
      simDay = 1+(frame/3600)|0;
    }
    if (frame%300===0) detectChambers();
  }
  render();
  updateHUD();
  requestAnimationFrame(tick);
}

// ═══════════════════════════════════════════════════════════
//  UI
// ═══════════════════════════════════════════════════════════

function updateHUD() {
  const pct = (totalDug/((ROWS-SURFACE)*COLS)*100).toFixed(1);
  document.getElementById('sAnts').textContent = ants.length;
  document.getElementById('sTunnel').textContent = pct+'%';
  document.getElementById('sChambers').textContent = chambers.length;
  document.getElementById('sDug').textContent = totalDug;
  document.getElementById('sDay').textContent = simDay;
}

function dropAnts(n) {
  for (let i=0;i<n;i++) ants.push(new Ant(Math.random()*(W-60)+30, (SURFACE-1)*CELL));
  toast(n+' ant'+(n>1?'s':'')+' released');
}

function dropFood() {
  foods.push({x:Math.random()*(W-40)+20, y:SURFACE_PX-CELL, amount:4+(Math.random()*5)|0});
  toast('Food placed');
}

function cycleSpeed() {
  const s=[1,2,4,8]; speed=s[(s.indexOf(speed)+1)%s.length];
  document.getElementById('speedLabel').textContent=speed+'x';
  toast('Speed: '+speed+'x');
}

function togglePause() {
  paused=!paused;
  document.getElementById('pauseBtn').textContent=paused?'play':'pause';
  toast(paused?'Paused':'Resumed');
}

function toast(msg) {
  const el=document.getElementById('toast');el.textContent=msg;el.classList.add('show');
  clearTimeout(el._t);el._t=setTimeout(()=>el.classList.remove('show'),1800);
}

canvas.addEventListener('click', e => {
  const rect=canvas.getBoundingClientRect();
  const sx=W/rect.width,sy=H/rect.height;
  const x=(e.clientX-rect.left)*sx,y=(e.clientY-rect.top)*sy;
  const gx=(x/CELL)|0,gy=(y/CELL)|0;
  // Only allow interaction within the frame
  if (x < FRAME || x > W-FRAME || y < FRAME || y > H-FRAME*2.5) return;
  if(gy<=SURFACE+1){ants.push(new Ant(x,Math.min(y,SURFACE_PX-2)));toast('Ant dropped');}
  else{const r=4;for(let dy=-r;dy<=r;dy++)for(let dx=-r;dx<=r;dx++)if(dx*dx+dy*dy<=r*r)dig(gx+dx,gy+dy);spawnDirt(x,y);}
});

function begin() {
  document.getElementById('intro').classList.add('hide');
  setTimeout(() => {
    document.getElementById('intro').style.display='none';
    document.getElementById('app').classList.add('show');
    canvas.width = W; canvas.height = H;
    resizeCanvas();
    generateSandNoise();
    initTerrain();
    dropAnts(8);
    running = true;
    tick();
  }, 500);
}

function resizeCanvas() {
  const wrap = document.getElementById('wrap');
  const ww = wrap.clientWidth, wh = wrap.clientHeight;
  const aspect = W / H;
  const wrapAspect = ww / wh;
  let cw, ch;
  if (wrapAspect > aspect) {
    ch = wh; cw = wh * aspect;
  } else {
    cw = ww; ch = ww / aspect;
  }
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
}

window.addEventListener('resize', () => { if(running) resizeCanvas(); });
</script>
</body>
</html>
